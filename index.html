<!DOCTYPE html>
<html lang="en">
<head>
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Azure Identity Workshop - Instructions</title>

	<meta charset="utf-8">
	<meta name="description" content="A workshop guide for Azure and Windows Identity">
	<meta name="author" content="Mike Branstein">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="css/style.css" rel="stylesheet">
</head>
<body>

<div id="container">
	<div id="header">
		<a href="#" class="menu header-btn" id="toggle-toc"></a>
		<h1>Azure Identity Workshop - Instructions</h1>
		<a href="https://github.com/mikebranstein/azure-identity-workshop-instructions" class="github header-btn"></a>
	</div>

	<div id="content-container">
		<div id="toc">
			<div class="toc-heading">Table of Contents</div>
			<div id="toc-padding"></div>
		</div>
		<div id="book">
			<div class="chapter">
				<h2 id="introduction">Introduction</h2>
<p>Welcome to the AZure Identity Workshop! </p>
<p>All around the world user groups and communities want to learn about Azure and Cloud Computing! On April 22, 2017, all communities will come together once again in the fifth great Global Azure Bootcamp event! Each user group will organize their own one day deep dive class on Azure the way they see fit and how it works for their members. The result is that thousands of people get to learn about Azure and join together online under the social hashtag #GlobalAzure! Join hundreds of other organizers to help out and be part of the experience! </p>
<h3 id="about-the-azure-identity-workshop">About the Azure Identity Workshop</h3>
<p>The Azure Identity Workshop is a free, developer-focused, one-day training event on Azure. </p>
<p>Content is presented and facilitated by:</p>
<ul>
<li><a href="https://twitter.com/mikebranstein">Mike Branstein</a><ul>
<li><a href="http://kizan.com">KiZAN Technologies</a></li>
<li><a href="https://brosteins.com">Brosteins</a></li>
</ul>
</li>
</ul>
<h3 id="getting-started">Getting Started</h3>
<p>To get started you&#39;ll need the following pre-requisites. Please take a few moments to ensure everything is installed and configured.</p>
<ul>
<li>Microsoft Windows PC</li>
<li><a href="https://www.visualstudio.com">Visual Studio</a> 2015 or later (2017 preferred)</li>
<li><a href="https://azure.microsoft.com">Azure Subscription</a> (Trial is ok, or an Azure account linked to a Visual Studio subscription or MSDN account. See later sections of this chapter to create a free trial account or activate your Visual Studio subscription)</li>
<li><a href="https://azure.microsoft.com/en-us/downloads/">Azure SDK for .NET</a> installed (be sure to get the right one for your version of Visual Studio)</li>
<li><a href="http://storageexplorer.com/">Storage Explorer</a> installed</li>
<li><a href="https://go.microsoft.com/fwlink/?LinkId=717179&amp;clcid=0x409">Storage Emulator</a> installed</li>
<li>The <a href="https://github.com/mikebranstein/azure-identity-workshop/tree/start">starter project</a> on Github</li>
</ul>
<h3 id="what-you-re-building">What You&#39;re Building</h3>
<p>Azure is big. Really big. Too big to talk about all things Azure in a single day. </p>
<p>We&#39;ve assembled an exciting workshop to introduce you to several Azure services that cloud developers should know about:</p>
<ul>
<li><a href="https://azure.microsoft.com/en-us/services/app-service/web/">Web app</a></li>
<li><a href="https://azure.microsoft.com/en-us/services/storage/blobs/">BLOB storage</a></li>
<li><a href="https://azure.microsoft.com/en-us/services/storage/tables/">Table storage</a></li>
<li><a href="https://azure.microsoft.com/en-us/services/functions/">Functions</a></li>
<li><a href="https://www.microsoft.com/cognitive-services">Cognitive Services</a> API for <a href="https://www.microsoft.com/cognitive-services/en-us/computer-vision-api">computer vision</a></li>
<li><a href="https://www.asp.net/signalr">SignalR</a> (yeah it&#39;s not a Azure service, but it is pretty cool)</li>
</ul>
<p>In this workshop you&#39;ll learn how to use these Azure services to build a cloud-hosted single sign-on app that can manage your user profile. When you&#39;re finished, you will have built an app that allows you to upload profile pictures that pass through an AI content filter to ensure they&#39;re work appropriate. </p>
<h4 id="key-concepts-and-takeaways">Key concepts and takeaways</h4>
<ul>
<li>Navigating the Azure portal</li>
<li>Using Azure Resource Groups to manage multiple Azure services</li>
<li>Deploying a web app to Azure web app service</li>
<li>Using Windows Identity as a login provider</li>
<li>Creating Azure storage accounts</li>
<li>Azure Table storage </li>
<li>Storing images in Azure BLOB storage</li>
<li>Using Azure functions to coordinate asynchronous processes</li>
<li>Consuming the Microsoft Cognitive Services API to analyze images</li>
<li>Using SignalR to asynchronously update web UIs</li>
</ul>
<h3 id="materials">Materials</h3>
<p>You can find additional lab materials and presentation content at the locations below:</p>
<ul>
<li>Presentation: <a href="https://github.com/mikebranstein/azure-identity-workshop/blob/master/Azure%20Bootcamp.pptx">https://github.com/mikebranstein/azure-identity-workshop/blob/master/Azure%20Bootcamp.pptx</a></li>
<li>Source code for the code used in this guide: <a href="https://github.com/mikebranstein/azure-identity-workshop">https://github.com/mikebranstein/azure-identity-workshop</a></li>
<li>This guide: <a href="https://mikebranstein.github.io/azure-identity-workshop-instructions/">https://github.com/mikebranstein/azure-identity-workshop-instructions</a></li>
</ul>
<h3 id="creating-a-trial-azure-subscription">Creating a Trial Azure Subscription</h3>
<blockquote>
<p><strong>NOTE:</strong> If you have an Azure account already, you can skip this section. If you have a Visual Studio subscription (formerly known as an MSDN account), you get free Azure dollars every month. Check out the next section for activating these benefits.</p>
</blockquote>
<p>There are several ways to get an Azure subscription, such as the free trial subscription, the pay-as-you-go subscription, which has no minimums or commitments and you can cancel any time; Enterprise agreement subscriptions, or you can buy one from a Microsoft retailer. In exercise, you&#39;ll create a free trial subscription.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Create a Free Trial Subscription
</h4>

<p>Browse to the following page <a href="http://azure.microsoft.com/en-us/pricing/free-trial/">http://azure.microsoft.com/en-us/pricing/free-trial/</a> to obtain a free trial account.</p>
<p>Click <em>Start free</em>.</p>
<p>Enter the credentials for the Microsoft account that you want to use. You will be redirected to the Sign up page.</p>
<blockquote>
<p><strong>NOTE:</strong> Some of the following sections could be omitted in the Sign up process, if you recently verified your Microsoft account.</p>
</blockquote>
<p>Enter your personal information in the About you section. If you have previously loaded this info in your Microsoft Account, it will be automatically populated.</p>
<p><img src="images/chapter0/sign-up.png" class="img-medium" /></p>
<p>In the <em>Verify by phone</em> section, enter your mobile phone number, and click <em>Send text message</em>.</p>
<p><img src="images/chapter0/send-text-message.png" class="img-medium" /></p>
<p>When you receive the verification code, enter it in the corresponding box, and click <em>Verify code</em>.</p>
<p><img src="images/chapter0/verify-code.png" class="img-medium" /></p>
<p>After a few seconds, the <em>Verification by card</em> section will refresh. Fill in the Payment information form. </p>
<blockquote>
<p><strong>NOTE:</strong> Your credit card will not be billed, unless you remove the spending limits. If you run out of credit, your services will be shut down unless you choose to be billed.</p>
</blockquote>
<p><img src="images/chapter0/verify-by-card.png" class="img-medium" /></p>
<p>In the <em>Agreement</em> section, check the <em>I agree to the subscription Agreement</em>, <em>offer details</em>, and <em>privacy statement</em> option, and click <em>Sign up</em>.</p>
<p>Your free subscription will be set up, and after a while, you can start using it. Notice that you will be informed when the subscription expires.</p>
<p><img src="images/chapter0/agreement.png" class="img-medium" /></p>
<p>Your free trial will expire in 29 days from it&#39;s creation.</p>
<p><img src="images/chapter0/expiration.png" class="img-medium" /></p>
<div class="exercise-end"></div>

<h3 id="activating-visual-studio-subscription-benefits">Activating Visual Studio Subscription Benefits</h3>
<p>If you happen to be a Visual Studio subscriber (formerly known as MSDN) you can activate your Azure Visual Studio subscription benefits. It is no charge, you can use your MSDN software in the cloud, and most importantly you get up to $150 in Azure credits every month. You can also get 33% discount in Virtual Machines and much more.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Activate Visual Studio Subscription Benefits
</h4>

<p>To active the Visual Studio subscription benefits, browse to the following URL: <a href="http://azure.microsoft.com/en-us/pricing/member-offers/msdn-benefits-details/">http://azure.microsoft.com/en-us/pricing/member-offers/msdn-benefits-details/</a></p>
<p>Scroll down to see the full list of benefits you will get for being a MSDN member. There is even a FAQ section you can read.</p>
<p>Click <em>Activate</em> to activate the benefits.</p>
<p><img src="images/chapter0/activate.png" class="img-medium" /></p>
<p>You will need to enter your Microsoft account credentials to verify the subscription and complete the activation steps.</p>
<div class="exercise-end"></div>

			</div>
			<hr>
			<div class="chapter">
				<h2 id="getting-project-from-github">Getting project from Github</h2>
<p>All the code you&#39;ll need for working through the workshop are stored on Github at <a href="https://github.com/mikebranstein/azure-identity-workshop">https://github.com/mikebranstein/azure-identity-workshop</a>.</p>
<h3 id="organization-of-the-repository">Organization of the Repository</h3>
<p>The repository at <a href="https://github.com/mikebranstein/azure-identity-workshop">https://github.com/mikebranstein/azure-identity-workshop</a> is organized into several <a href="https://github.com/mikebranstein/azure-identity-workshop/branches/all">branches</a>:</p>
<ul>
<li>start</li>
<li>chapter2</li>
<li>chapter5</li>
<li>chapter6</li>
<li>chapter7</li>
<li>chapter9</li>
</ul>
<p>Each branch corresponds with the chapters in this workshop guide. The guide starts with the code from the <code>start</code> branch, and progresses with each chapter. </p>
<blockquote>
<p><strong>NOTE</strong> You don&#39;t need to copy the code from each branch, only the <code>start</code> branch. If you&#39;re following along with the guide, you can start with the <code>start</code> branch. If you get stuck, or if you can&#39;t follow-along, you can grab a fresh set of code from a branch name matching the chapter you&#39;re on. For example, if you get stuck and can&#39;t get your code working at the end of chapter 5, you can jump to chapter 6 and grab the <code>chapter6</code> branch.</p>
</blockquote>
<h3 id="pre-requisites">Pre-requisites</h3>
<p>Before we go any further, be sure you have all the pre-requisites downloaded and installed. You&#39;ll need the following:</p>
<ul>
<li>Microsoft Windows PC</li>
<li><a href="https://www.visualstudio.com">Visual Studio</a> 2015 or later</li>
<li><a href="https://azure.microsoft.com">Azure Subscription</a> (trial is ok, and we&#39;ll sign you up in our first session)</li>
<li><a href="https://azure.microsoft.com/en-us/downloads/">Azure SDK for .NET</a> installed (be sure to get the right one for your version of Visual Studio)</li>
<li><a href="http://storageexplorer.com/">Storage Explorer</a> installed</li>
<li><a href="https://go.microsoft.com/fwlink/?LinkId=717179&amp;clcid=0x409">Storage Emulator</a> installed</li>
<li>The <a href="https://github.com/mikebranstein/azure-identity-workshop/tree/start">starter project</a> on Github</li>
</ul>
<h3 id="clone-project-from-start-branch">Clone project from start branch</h3>
<p>Let&#39;s get started by getting the <code>start</code> branch.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Getting the code
</h4>

<p>Clone or download the <code>start</code> branch from <a href="https://github.com/mikebranstein/azure-identity-workshop/tree/start">https://github.com/mikebranstein/azure-identity-workshop/tree/start</a>).</p>
<p>Use this <a href="https://github.com/mikebranstein/azure-identity-workshop/archive/start.zip">link</a> to download a zip file of the <code>start</code> branch.</p>
<p><img src="images/chapter1/downloaded-zip.png" alt="image"></p>
<blockquote>
<p>Don&#39;t open the zip file yet. You need to unblock it first!</p>
</blockquote>
<p>Right-click the zip file and go to the properties option. Check the <em>Unblock</em> option, press <em>Apply</em>, press <em>Ok</em>.</p>
<p><img src="images/chapter1/unblock.gif" alt="image"></p>
<p>Now it&#39;s safe to unzip the file. </p>
<div class="exercise-end"></div>

<h3 id="verify-the-site-works">Verify the site works</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Compiling the solution
</h4>

<p>Open the solution in Visual Studio by double-clicking the <code>Web.sln</code> file in to root of the extracted files:</p>
<p><img src="images/chapter1/solution-file.png" alt="image"></p>
<p>The opened solution should look like this:</p>
<p><img src="images/chapter1/opened-solution.png" alt="image"></p>
<p>Build and debug the solution. You should see the MVC 5 template spin up in your browser.</p>
<p><img src="images/chapter1/site.png" alt="image"></p>
<div class="exercise-end"></div>

<p>That&#39;s it! You&#39;re up and running and ready to move on!</p>

			</div>
			<hr>
			<div class="chapter">
				<h2 id="updating-windows-identity">Updating Windows Identity</h2>
<p>In this chapter, you&#39;ll be learning about ASP.NET Identity and how to move it&#39;s back-end data store from SQL Server to Azure Table Storage.</p>
<p>Before we begin, let&#39;s cover a few basics on what ASP.NET Identity is and how it works. </p>
<h3 id="a-brief-history-of-asp-net-authentication-and-authorization">A brief history of ASP.NET authentication and authorization</h3>
<p>If you&#39;ve developed an ASP.NET application prior to 2014, you&#39;ve probably heard of the ASP.NET membership system. </p>
<p>The ASP.NET membership system was introduced with ASP.NET 2.0 back in 2005, and since then there have been many changes in the ways web applications typically handle authentication and authorization (credits: <a href="https://docs.microsoft.com/en-us/aspnet/identity/overview/getting-started/introduction-to-aspnet-identity">docs.microsoft.com</a>).</p>
<blockquote>
<p>Credit for this section is attributed to <a href="https://docs.microsoft.com/en-us/aspnet/identity/overview/getting-started/introduction-to-aspnet-identity">Microsoft</a>.</p>
</blockquote>
<h4 id="asp-net-membership">ASP.NET Membership</h4>
<p><a href="https://msdn.microsoft.com/en-us/library/yh26yfzy.aspx">ASP.NET Membership</a> was designed to solve site membership requirements that were common in 2005, which involved Forms Authentication, and a SQL Server database for user names, passwords, and profile data. Today there is a much broader array of data storage options for web applications, and most developers want to enable their sites to use social identity providers for authentication and authorization functionality. The limitations of ASP.NET Membership&#39;s design make this transition difficult:</p>
<ul>
<li>The database schema was designed for SQL Server and you can&#39;t change it. You can add profile information, but the additional data is packed into a different table, which makes it difficult to access by any means except through the Profile Provider API.</li>
<li>The provider system enables you to change the backing data store, but the system is designed around assumptions appropriate for a relational database. You can write a provider to store membership information in a non-relational storage mechanism, such as Azure Storage Tables, but then you have to work around the relational design by writing a lot of code and a lot of <code>System.NotImplementedException</code> exceptions for methods that don&#39;t apply to NoSQL databases.</li>
<li>Since the log-in/log-out functionality is based on Forms Authentication, the membership system can&#39;t use <a href="https://docs.microsoft.com/en-us/aspnet/aspnet/overview/owin-and-katana/an-overview-of-project-katana">OWIN</a>. OWIN includes middleware components for authentication, including support for log-ins using external identity providers (like Microsoft Accounts, Facebook, Google, Twitter), and log-ins using account from on-premises Active Directory or <a href="https://azure.microsoft.com/en-us/services/active-directory/">Azure Active Directory</a>. OWIN also includes support for OAuth 2.0, JWT and CORS.</li>
</ul>
<h4 id="asp-net-simple-membership">ASP.NET Simple Membership</h4>
<p><a href="https://docs.microsoft.com/en-us/aspnet/web-pages/overview/security/16-adding-security-and-membership">ASP.NET Simple Membership</a> was developed as a membership system for ASP.NET Web Pages. It was released with WebMatrix and Visual Studio 2010 SP1. The goal of Simple Membership was to make it easy to add membership functionality to a Web Pages application.</p>
<p>Simple Membership did make it easier to customize user profile information, but it still shares the other problems with ASP.NET Membership, and it has some limitations:</p>
<ul>
<li>It was hard to persist membership system data in a non-relational store.</li>
<li>You can&#39;t use it with OWIN.</li>
<li>It doesn&#39;t work well with existing ASP.NET Membership providers, and it&#39;s not extensible.</li>
</ul>
<h4 id="asp-net-universal-providers">ASP.NET Universal Providers</h4>
<p><a href="http://www.hanselman.com/blog/IntroducingSystemWebProvidersASPNETUniversalProvidersForSessionMembershipRolesAndUserProfileOnSQLCompactAndSQLAzure.aspx">ASP.NET Universal Providers</a> were developed to make it possible to persist membership information in Microsoft Azure SQL Database, and they also work with SQL Server Compact. The Universal Providers were built on Entity Framework Code First, which means that the Universal Providers can be used to persist data in any store supported by EF. With the Universal Providers, the database schema was cleaned up quite a lot as well.</p>
<p>The Universal Providers are built on the ASP.NET Membership infrastructure, so they still carry the same limitations as the SqlMembership Provider. That is, they were designed for relational databases and it&#39;s hard to customize profile and user information. These providers also still use Forms Authentication for log-in and log-out functionality.</p>
<h3 id="exploring-asp-net-identity">Exploring ASP.NET Identity</h3>
<p>As the membership story in ASP.NET has evolved over the years, the ASP.NET team has learned a lot from feedback from customers.</p>
<p>The assumption that users will log in by entering a user name and password that they have registered in your own application is no longer valid. The web has become more social. Users are interacting with each other in real time through social channels such as Facebook, Twitter, and other social web sites. Developers want users to be able to log in with their social identities so that they can have a rich experience on their web sites. A modern membership system must enable redirection-based log-ins to authentication providers such as Facebook, Twitter, and others.</p>
<p>As web development evolved, so did the patterns of web development. Unit testing of application code became a core concern for application developers. In 2008 ASP.NET added a new framework based on the Model-View-Controller (MVC) pattern, in part to help developers build unit testable ASP.NET applications. Developers who wanted to unit test their application logic also wanted to be able to do that with the membership system.</p>
<p>Considering these changes in web application development, ASP.NET Identity was developed with the following goals:</p>
<ul>
<li><p><strong>One ASP.NET Identity system</strong></p>
<ul>
<li>ASP.NET Identity can be used with all of the ASP.NET frameworks, such as ASP.NET MVC, Web Forms, Web Pages, Web API, and SignalR.</li>
<li>ASP.NET Identity can be used when you are building web, phone, store, or hybrid applications.</li>
</ul>
</li>
<li><p><strong>Ease of plugging in profile data about the user</strong></p>
<ul>
<li>You have control over the schema of user and profile information. For example, you can easily enable the system to store birth dates entered by users when they register an account in your application.</li>
</ul>
</li>
<li><p><strong>Persistence control</strong></p>
<ul>
<li>By default, the ASP.NET Identity system stores all the user information in a database. ASP.NET Identity uses Entity Framework Code First to implement all of its persistence mechanism.</li>
<li>Since you control the database schema, common tasks such as changing table names or changing the data type of primary keys is simple to do.</li>
<li>It&#39;s easy to plug in different storage mechanisms such as SharePoint, Azure Storage Table Service, NoSQL databases, etc., without having to throw <code>System.NotImplementedExceptions</code> exceptions.</li>
</ul>
</li>
<li><p><strong>Unit testability</strong></p>
<ul>
<li>ASP.NET Identity makes the web application more unit testable. You can write unit tests for the parts of your application that use ASP.NET Identity.</li>
</ul>
</li>
<li><p><strong>Role provider</strong></p>
<ul>
<li>There is a role provider which lets you restrict access to parts of your application by roles. You can easily create roles such as &quot;Admin&quot; and add users to roles.</li>
</ul>
</li>
<li><p><strong>Claims Based</strong></p>
<ul>
<li>ASP.NET Identity supports claims-based authentication, where the user&#39;s identity is represented as a set of claims. Claims allow developers to be a lot more expressive in describing a user&#39;s identity than roles allow. Whereas role membership is just a boolean (member or non-member), a claim can include rich information about the user&#39;s identity and membership.</li>
</ul>
</li>
<li><p><strong>Social Login Providers</strong></p>
<ul>
<li>You can easily add social log-ins such as Microsoft Account, Facebook, Twitter, Google, and others to your application, and store the user-specific data in your application.</li>
</ul>
</li>
<li><p><strong>Azure Active Directory</strong></p>
<ul>
<li>You can also add log-in functionality using Azure Active Directory, and store the user-specific data in your application. To learn more about Azure Active Directory, check out this <a href="https://azure.microsoft.com/en-us/services/active-directory/">article</a>.</li>
</ul>
</li>
<li><p><strong>OWIN Integration</strong></p>
<ul>
<li>ASP.NET authentication is now based on OWIN middleware that can be used on any OWIN-based host. ASP.NET Identity does not have any dependency on System.Web. It is a fully compliant OWIN framework and can be used in any OWIN hosted application.</li>
<li>ASP.NET Identity uses OWIN Authentication for log-in/log-out of users in the web site. This means that instead of using FormsAuthentication to generate the cookie, the application uses OWIN CookieAuthentication to do that.</li>
</ul>
</li>
<li><p><strong>NuGet package</strong></p>
<ul>
<li>ASP.NET Identity is redistributed as a NuGet package which is installed in the ASP.NET MVC, Web Forms and Web API templates that ship with Visual Studio 2013. You can download this NuGet package from the NuGet gallery.</li>
<li>Releasing ASP.NET Identity as a NuGet package makes it easier for the ASP.NET team to iterate on new features and bug fixes, and deliver these to developers in an agile manner.</li>
</ul>
</li>
</ul>
<h3 id="getting-started-with-asp-net-identity">Getting Started with ASP.NET Identity</h3>
<p>ASP.NET Identity is used in the Visual Studio project templates for ASP.NET MVC, Web Forms, Web API and SPA. In this walk-through, we&#39;ll illustrate how the project templates use ASP.NET Identity to add functionality to register, log in and log out a user.</p>
<p>ASP.NET Identity is implemented using the following procedure. The purpose of this section is to give you a high level overview of ASP.NET Identity.</p>
<blockquote>
<p>You do not need to follow along with these steps, but are welcome to. </p>
</blockquote>
<ol>
<li><p>Create an ASP.NET MVC application with Individual Accounts. You can use ASP.NET Identity in ASP.NET MVC, Web Forms, Web API, SignalR etc. In this example we start with an ASP.NET MVC application.</p>
<p> <img src="images/chapter2/mvc-create.png" alt="image"></p>
</li>
<li><p>The created project contains the following three packages for ASP.NET Identity.</p>
<ul>
<li><p><strong>Microsoft.AspNet.Identity.EntityFramework</strong>
  This package has the Entity Framework implementation of ASP.NET Identity which will persist the ASP.NET Identity data and schema to SQL Server.</p>
</li>
<li><p><strong>Microsoft.AspNet.Identity.Core</strong>
  This package has the core interfaces for ASP.NET Identity. This package can be used to write an implementation for ASP.NET Identity that targets different persistence stores such as Azure Table Storage, NoSQL databases etc.</p>
</li>
<li><p><strong>Microsoft.AspNet.Identity.OWIN</strong>
  This package contains functionality that is used to plug in OWIN authentication with ASP.NET Identity in ASP.NET applications. This is used when you add log in functionality to your application and call into OWIN Cookie Authentication middleware to generate a cookie.</p>
</li>
</ul>
</li>
<li><p><strong>Registering a user.</strong> After the project is created, launch the web application. Click on the Register link to create a user. The following image shows the Register page which collects the user name and password.</p>
<p> <img src="images/chapter2/register.gif" class="img-medium" /></p>
<p> When the user clicks the Register button, the Register action of the Account controller creates the user by calling the ASP.NET Identity API. In the code snippet below, the <code>ApplicationUser</code> and <code>UserManager</code> classes are part of ASP.NET Identity. An <code>ApplicationUser</code> is created and passed to the <code>UserManager</code> class to create the user. </p>
<pre><code class="lang-csharp"> [HttpPost]
 [AllowAnonymous]
 [ValidateAntiForgeryToken]
 public async Task&lt;ActionResult&gt; Register(RegisterViewModel model)
 {
     if (ModelState.IsValid)
     {
         var user = new ApplicationUser { UserName = model.Email, Email = model.Email };
         var result = await UserManager.CreateAsync(user, model.Password);
         if (result.Succeeded)
         {
             // code truncated purposefully
         }
         AddErrors(result);
     }

     // If we got this far, something failed, re-display form
     return View(model);
 }
</code></pre>
<blockquote>
<p><strong>DEFINITION</strong> The <code>ApplicationUser</code> class is part of the ASP.NET MVC template, and inherits from the <code>IdentityUser</code> class. The class name doesn&#39;t matter, but inheriting from <code>IdentityUser</code> does. We&#39;re not going to cover the specifics of the <code>IdentityUser</code> class in this workshop, but it represents a user, with properties like <em>Name</em>, <em>Email</em>, <em>PhoneNumber</em>, etc. For more details on the <code>IdentityUser</code> class check out <a href="https://msdn.microsoft.com/en-us/magazine/dn818488.aspx">this article</a>.</p>
<p><strong>DEFINITION</strong> The <code>UserManager</code> class is part of ASP.NET Identity and provides methods for managing users. Strange, right? ;-) </p>
</blockquote>
<p> Luckily, the ASP.NET MVC template provides a solid foundation for us, so you don&#39;t need to know <em>everything</em> about ASP.NET Identity to start using it. As we continue, we&#39;ll make sure you know what you&#39;ll need to know as we go. </p>
</li>
<li><p><strong>Logging in.</strong> If user registration is successful, the user is automatically logged in. A call to the <code>SignInManager</code> class is made, passing the instance of the <code>ApplicationUser</code> previously created.  </p>
<pre><code class="lang-csharp"> [HttpPost]
 [AllowAnonymous]
 [ValidateAntiForgeryToken]
 public async Task&lt;ActionResult&gt; Register(RegisterViewModel model)
 {
     if (ModelState.IsValid)
     {
         var user = new ApplicationUser { UserName = model.Email, Email = model.Email };
         var result = await UserManager.CreateAsync(user, model.Password);
         if (result.Succeeded)
         {
             await SignInManager.SignInAsync(user, isPersistent:false, rememberBrowser:false);

             return RedirectToAction(&quot;Index&quot;, &quot;Home&quot;);
         }
         AddErrors(result);
     }

     // If we got this far, something failed, re-display form
     return View(model);
 }
</code></pre>
<blockquote>
<p><strong>DEFINITION</strong> The <code>SignInManager</code> class is also part of ASP.NET Identity and provides methods for managing the sign in processes.</p>
</blockquote>
<p> We&#39;re not diving into the details of what actually happens when a user is signed in (for example, creating a claim, cookie, etc.). If you&#39;re interested in the details, check out <a href="https://docs.microsoft.com/en-us/aspnet/identity/overview/getting-started/introduction-to-aspnet-identity">this article</a>.</p>
</li>
</ol>
<p>There are various other classes in ASP.NET Identity and the ASP.NET MVC template of importance, but we&#39;re not going to investigate them here. But, don&#39;t worry. We&#39;ll teach you about it as needed.</p>
<h3 id="asp-net-identity-data-storage">ASP.NET Identity Data Storage</h3>
<p>In this section, you&#39;ll be learning how to replace the back-end data storage platform of ASP.NET Identity. By default, ASP.NET Identity uses <a href="https://msdn.microsoft.com/en-us/library/aa937723.aspx">Entity Framework</a> to manage data persistence to SQL Server. </p>
<p>Using Entity Framework and SQL Server is a great choice. In fact, we <em>could</em> provision a SQL Server database in Azure, and use that for the back-end data store for ASP.NET Identity. </p>
<p>Instead, you&#39;ll be replacing Entity Framework and SQL Server with a highly-scalable and light-weight NoSQL Azure service called <a href="https://azure.microsoft.com/en-us/services/storage/tables/">Table storage</a>. </p>
<p>Before we jump in, let&#39;s learn a little bit about Azure Table Storage.</p>
<h3 id="what-is-azure-table-storage-">What is Azure Table Storage?</h3>
<p>Azure Table storage is a service that stores structured NoSQL data in the cloud, providing a key/attribute store with a schemaless design. Because Table storage is schemaless, it&#39;s easy to adapt your data as the needs of your application evolve. Access to Table storage data is fast and cost-effective for many types of applications, and is typically lower in cost than traditional SQL for similar volumes of data.</p>
<p>You can use Table storage to store flexible datasets like user data for web applications, address books, device information, or other types of metadata your service requires. You can store any number of entities in a table, and a storage account may contain any number of tables, up to the capacity limit of the storage account</p>
<h4 id="the-azure-table-service">The Azure Table Service</h4>
<p>The Azure Table storage service stores large amounts of structured data. The service is a NoSQL datastore which accepts authenticated calls from inside and outside the Azure cloud. Azure tables are ideal for storing structured, non-relational data. Common uses of the Table service include:</p>
<ul>
<li>Storing TBs of structured data capable of serving web scale applications</li>
<li>Storing datasets that don&#39;t require complex joins, foreign keys, or stored procedures and can be denormalized for fast access</li>
<li>Quickly querying data using a clustered index</li>
<li>Accessing data using the OData protocol and LINQ queries with WCF Data Service .NET Libraries</li>
</ul>
<p>You can use the Table service to store and query huge sets of structured, non-relational data, and your tables will scale as demand increases.</p>
<h4 id="table-service-concepts">Table Service Concepts</h4>
<p>The Table service contains the following components:</p>
<p><img src="images/chapter2/table-service.png" alt="image"></p>
<p>At the top level is a storage account. Storage accounts are named containers with a URL, which is used to access various services housed within the account. You&#39;ll be creating a storage account later in the workshop.</p>
<p>There are various concepts important to know about Azure Table Storage:</p>
<ul>
<li><p><strong>URL format:</strong> You can access tables and entities through code using this address format: http://<code>&lt;storage account&gt;</code>.table.core.windows.net/<code>&lt;table&gt;</code>
You can also address Azure tables directly using this address with the OData protocol. For more information, see <a href="OData.org">OData.org</a>.</p>
</li>
<li><p><strong>Storage Account:</strong> All access to Azure Storage is done through a storage account. </p>
</li>
<li><p><strong>Table:</strong> A table is a collection of entities. Tables don&#39;t enforce a schema on entities, which means a single table can contain entities that have different sets of properties. The number of tables that a storage account can contain is limited only by the storage account capacity limit.</p>
</li>
<li><p><strong>Entity:</strong> An entity is a set of properties, similar to a database row. An entity can be up to 1MB in size.</p>
</li>
<li><p><strong>Properties:</strong> A property is a name-value pair. Each entity can include up to 252 properties to store data. Each entity also has 3 system properties that specify a partition key, a row key, and a timestamp. Entities with the same partition key can be queried more quickly, and inserted/updated in atomic operations. An entity&#39;s row key is its unique identifier within a partition.</p>
</li>
</ul>
<h4 id="comparing-table-storage-to-sql-server-tables">Comparing Table storage to SQL Server tables</h4>
<p>If you&#39;re familiar with SQL server, you can compare it easily to the storage account, table service, tables, and entities:</p>
<ul>
<li>SQL Server == Storage Account</li>
<li>Database == Table Service</li>
<li>Table == Table</li>
<li>Record == Entity</li>
<li>Column == Property</li>
</ul>
<p>Now that you know about Table storage, let&#39;s get to work replacing Entity Framework and SQL Server as the back-end store for ASP.NET Identity.</p>
<h3 id="replacing-the-back-end-data-store-of-asp-net-identity">Replacing the back-end Data Store of ASP.NET Identity</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Removing Entity Framework
</h4>

<p>Start by right-clicking your solution in the Visual Studio solution explorer and selecting <em>Manage NuGet Packages for Solution...</em>.</p>
<p><img src="images/chapter2/manage-nuget.png" alt="image"></p>
<p>In the NuGet window, click on <em>Installed</em>, type in <em>entity</em> in the <em>Search</em> bar:</p>
<p><img src="images/chapter2/search-nuget.gif" alt="image"></p>
<p>Uninstall these NuGet packages in the following order:</p>
<ul>
<li>Microsoft.AspNet.Identity.EntityFramework</li>
<li>EntityFramework</li>
</ul>
<p><img src="images/chapter2/uninstall-ef.gif" class="img-medium" /></p>
<p>We&#39;re not done yet, so hold on. There are several references to Entity Framework in the <code>web.config</code> file. Remove the following:</p>
<p>In <code>&lt;configSections&gt;</code>, remove the section named <em>entityFramework</em>. Leave the <code>&lt;configSections&gt;</code> element in place, because we&#39;ll be adding to it later.</p>
<pre><code class="lang-xml">&lt;configSections&gt;
    &lt;section name=&quot;entityFramework&quot; type=&quot;System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&quot; requirePermission=&quot;false&quot; /&gt;
&lt;/configSections&gt;
</code></pre>
<p>Delete the connection string named <code>DefaultConnection</code>:</p>
<pre><code class="lang-xml">&lt;connectionStrings&gt;
    &lt;add name=&quot;DefaultConnection&quot; connectionString=&quot;Data Source=(LocalDb)\MSSQLLocalDB;AttachDbFilename=|DataDirectory|\aspnet-Web-20170403111511.mdf;Initial Catalog=aspnet-Web-20170403111511;Integrated Security=True&quot; providerName=&quot;System.Data.SqlClient&quot; /&gt;
&lt;/connectionStrings&gt;
</code></pre>
<p>Scroll to element named <code>&lt;entityFramework&gt;...&lt;/entityFramework&gt;</code> near the end of the file. Remove the entire element:</p>
<pre><code class="lang-xml">&lt;entityFramework&gt;
    &lt;defaultConnectionFactory type=&quot;System.Data.Entity.Infrastructure.LocalDbConnectionFactory, EntityFramework&quot;&gt;
        &lt;parameters&gt;
        &lt;parameter value=&quot;mssqllocaldb&quot; /&gt;
        &lt;/parameters&gt;
    &lt;/defaultConnectionFactory&gt;
    &lt;providers&gt;
        &lt;provider invariantName=&quot;System.Data.SqlClient&quot; type=&quot;System.Data.Entity.SqlServer.SqlProviderServices, EntityFramework.SqlServer&quot; /&gt;
    &lt;/providers&gt;
&lt;/entityFramework&gt;
</code></pre>
<div class="exercise-end"></div>

<p>Now that we&#39;ve removed Entity Framework, we need to replace it. If you recall, Entity Framework was used by ASP.NET Identity as a middleware to map between ASP.NET Identity code objects (like the <code>IdentityUser</code> class) and the back-end data store. </p>
<p>We&#39;ll be using Azure Table storage as our data store, so we&#39;ll have to add another library to act as the middleware for persisting data to Azure Table storage. The package we&#39;ll be using is named <em>ElCamino.AspNet.Identity.AzureTable</em>.</p>
<blockquote>
<p><strong>NOTE</strong> The El Camino package is maintained by David Melendez on <a href="https://github.com/dlmelendez/identityazuretable">Github</a>. By default, the ASP.NET Identity system stores all the user information in a Microsoft SQL database using an EntityFramework provider. This project is a replacement of the EntityFramework SQL provider to use Azure Table Storage to persist user information such as (but not limited to): username/password, roles, claims and external login information.</p>
</blockquote>
<h4 class="exercise-start">
    <b>Exercise</b>: Adding the ElCamino.AspNet.Identity.AzureTable package
</h4>

<p>Open the NuGet package manager for the solution, browse for and install the ElCamino.AspNet.Identity.AzureTable NuGet package:</p>
<p><img src="images/chapter2/install-elcamino.gif" class="img-medium" /></p>
<p>The installation of this package will install various additional packages. If prompted, allow them to be installed. Also accept any license agreements, if prompted.</p>
<p>After the <em>ElCamino.AspNet.Identity.AzureTable</em> package has been installed, there will be several NuGet packages that need updated. Click the <em>Updates</em> link and update all NuGet packages</p>
<p><img src="images/chapter2/update-nuget2.gif" class="img-medium" /></p>
<blockquote>
<p><strong>NOTE</strong> You may need to update the NuGet packages several times, as various packages will install new dependencies during the upgrade process.</p>
</blockquote>
<div class="exercise-end"></div>

<p>Now that the easy part is finished, it&#39;s time to start updating code to account for a new back-end data store. ASP.NET Identity makes this relatively painless. Let&#39;s get started.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Updating ASP.NET Identity code to replace Entity Framework
</h4>

<h4 id="identitymodel-cs-changes">IdentityModel.cs Changes</h4>
<p>The first code change we&#39;ll make is to the <code>IdentityModel.cs</code> file. You can find this file in the <code>Models</code> folder of the web project.</p>
<p><img src="images/chapter2/identity-model.png" alt="image"></p>
<p>Replace the using statements at the top, removing the Entity Framework references and adding the ElCamino references.</p>
<blockquote>
<p><strong>NOTE</strong> Throughout the workshop, feel free to copy and paste code directly from the guide into Visual Studio. There&#39;s a handy <em>Copy</em> button above our code listings!</p>
</blockquote>
<pre><code class="lang-csharp">using System.Security.Claims;
using System.Threading.Tasks;
using Microsoft.AspNet.Identity;
using ElCamino.AspNet.Identity.AzureTable;
using ElCamino.AspNet.Identity.AzureTable.Model;
</code></pre>
<p>Find the class declaration for <code>ApplicationDbContext</code>. This class is an abstraction used to interface between the ASP.NET MVC template code for ASP.NET Identity and the middleware that interfaces with ASP.NET Identity. The class currently inherits from <code>IdentityDbContext&lt;&gt;</code>. </p>
<p>Change the class declaration so it inherits from <code>IdentityCloudContext</code>. Also remove the parameterized base class constructor. The new <code>ApplicationDbContext</code> class should look like this:</p>
<pre><code class="lang-csharp">public class ApplicationDbContext : IdentityCloudContext
{
    public ApplicationDbContext() : base() { }

    public static ApplicationDbContext Create()
    {
        return new ApplicationDbContext();
    }
}
</code></pre>
<h4 id="identityconfig-cs-changes">IdentityConfig.cs Changes</h4>
<p>The next file we&#39;ll change is the <code>IdentityConfig.cs</code> file, located in the <code>App_Start</code> folder:</p>
<p><img src="images/chapter2/identity-config.png" alt="image"></p>
<p>This file contains a variety of class definitions used by the ASP.NET MVC template. The most important of the classes is the <code>ApplicationUserManager</code> class. This class is responsible for configuring policies and defaults for user accounts in the application (for example, the password validation policy, user email address uniqueness, lockout period if a password is typed in wrong X number of times, and multi-factor authentication via SMS and/or email).</p>
<p>The <code>ApplicationUserManager</code> class also contains a reference to the back-end data store used to store user account information. We&#39;ll be modifying the class to auto-create the necessary tables if they don&#39;t exist.  </p>
<p>Start by replacing the using statements at the top, removing the Entity Framework references and adding the ElCamino references.</p>
<pre><code class="lang-csharp">using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Claims;
using System.Threading.Tasks;
using System.Web;
using Microsoft.AspNet.Identity;
using Microsoft.AspNet.Identity.Owin;
using Microsoft.Owin;
using Microsoft.Owin.Security;
using Web.Models;
using ElCamino.AspNet.Identity.AzureTable;
using ElCamino.AspNet.Identity.AzureTable.Model;
</code></pre>
<p>Next, add a function named <code>StartupAsync()</code> that creates a new <code>UserStore</code> and creates the necessary Azure Tables. Place the below code beneath the <code>ApplicationUserManager</code> class constructor.</p>
<blockquote>
<p><strong>NOTE</strong> You might be wondering how we came up with this code. ElCamino has documentation online with this well-documented code. If you&#39;re interested in the details and their implementation specifics, check out their <a href="https://dlmelendez.github.io/identityazuretable/#/walkthrough">website</a>.</p>
</blockquote>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// ElCamino - Creates the Azure Table Storage Tables
/// &lt;/summary&gt;
public static async void StartupAsync()
{
    var azureStore = new UserStore&lt;ApplicationUser&gt;(new ApplicationDbContext());
    await azureStore.CreateTablesIfNotExists();
}
</code></pre>
<h4 id="global-asax-cs-changes">Global.asax.cs Changes</h4>
<p>Unfortunately, the <code>StartupAsync()</code> function you just added doesn&#39;t get called automatically. We&#39;ll need to update the <code>Global.asax.cs</code> file to invoke the <code>StartupAsync()</code> function when the application starts.</p>
<pre><code class="lang-csharp">using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.Mvc;
using System.Web.Optimization;
using System.Web.Routing;

namespace Web
{
    public class MvcApplication : System.Web.HttpApplication
    {
        protected void Application_Start()
        {
            //ElCamino - Added to create azure tables
            ApplicationUserManager.StartupAsync();

            AreaRegistration.RegisterAllAreas();
            FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters);
            RouteConfig.RegisterRoutes(RouteTable.Routes);
            BundleConfig.RegisterBundles(BundleTable.Bundles);
        }
    }
}
</code></pre>
<h4 id="web-config-changes">web.config Changes</h4>
<p>The last step is to update the <code>web.config</code> file and add several ElCamino references to configure the middleware and specify a connection string to connect to Azure.</p>
<p>Replace the <code>&lt;configSections&gt;...&lt;/configSections&gt;</code> element with the following code:</p>
<pre><code class="lang-xml">  &lt;configSections&gt;
    &lt;section name=&quot;elcaminoIdentityConfiguration&quot; type=&quot;ElCamino.AspNet.Identity.AzureTable.Configuration.IdentityConfigurationSection,ElCamino.AspNet.Identity.AzureTable &quot; /&gt;
  &lt;/configSections&gt;
  &lt;elcaminoIdentityConfiguration tablePrefix=&quot;&quot; storageConnectionString=&quot;UseDevelopmentStorage=true&quot; /&gt;
  &lt;!--&lt;elcaminoIdentityConfiguration tablePrefix=&quot;&quot; storageConnectionString=&quot;DefaultEndpointsProtocol=https;AccountName=STORAGE_ACCOUNT_NAME;AccountKey=STORAGE_ACCOUNT_KEY;&quot; /&gt;--&gt;
</code></pre>
<p>By adding these XML settings, we&#39;re now able to specify an azure table storage account connection string via the web.config file. You may notice the connection string is <code>UseDevelopmentStorage=true</code>. This allows us to develop locally without interfacing directly with Azure.  You&#39;ll learn the details of this soon, so hang in there. </p>
<div class="exercise-end"></div>

<p>Nice work! We&#39;ve finished replacing the back-end data store of ASP.NET Identity to use Azure Table storage instead of Entity Framework and SQL Server. </p>
<p>If you&#39;ve been following along, you should be able to compile the solution. Go ahead and try.</p>
<p><img src="images/chapter2/recompile-success.png" alt="image"></p>
<p>In the next chapter, you&#39;ll learn how we can develop locally by using the Azure Storage emulator, and how to create an Azure storage account in the cloud.</p>

			</div>
			<hr>
			<div class="chapter">
				<h2 id="using-azure-storage-emulator-to-develop-locally">Using Azure Storage Emulator to Develop Locally</h2>
<p>Even though this workshop is all about the cloud and using Azure, it doesn&#39;t mean that we need to be connected to the cloud to develop and test our work.</p>
<p>In fact, an important aspect of a technology stack is being able to quickly and easily create an isolated (and local) environment for development and testing. </p>
<p>In this section, you&#39;ll learn how to use the Azure Storage Emulator to host your own Azure-like table storage environment. You&#39;ll also learn how to use Storage Explorer, a GUI application (similar to SQL Server Management Studio), that allows you to navigate and browse through your Azure storage accounts.  </p>
<h3 id="pre-requisite-check">Pre-requisite Check</h3>
<p>Before we jump in, be sure to have installed these tools:</p>
<ul>
<li><a href="https://go.microsoft.com/fwlink/?linkid=717179&amp;clcid=0x409">Azure Storage Emulator</a></li>
<li><a href="http://storageexplorer.com/">Storage Explorer</a></li>
</ul>
<h3 id="running-azure-storage-emulator">Running Azure Storage Emulator</h3>
<p>The Azure Storage Emulator is a command line tool. Let&#39;s start it up.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Starting up the Azure Storage Emulator
</h4>

<p>Locate the <code>Microsoft Azure Storage Emulator - vX.X</code> in your start menu. </p>
<blockquote>
<p><strong>NOTE</strong> I find it easiest to find by opening the start menu and typing <code>storage</code>.</p>
</blockquote>
<p><img src="images/chapter3/run-storage-emulator.gif" alt="image"></p>
<p>When you run the storage emulator, a command prompt will open, initialize the emulator by installing a SQL database into your (localdb)\MSSQLLocalDB instance, and start the emulator.</p>
<p>After the emulator is started, a tray icon will appear noting the emulator is running:</p>
<p><img src="images/chapter3/emulator-running.png" alt="image"></p>
<h4 id="troubleshooting-the-storage-emulator">Troubleshooting the Storage Emulator</h4>
<p>You may have problems starting the storage emulator, and will receive an ambiguous error:</p>
<p><img src="images/chapter3/emulator-error.png" class="img-medium" /></p>
<p>There&#39;s a number of reasons why you may receive this error, including:</p>
<ul>
<li>Another program is listening on ports 10000, 10001, and 10002. Try shutting off Bit Torrent clients or other file sharing programs.</li>
<li>You&#39;re not running the emulator as an Administrator.</li>
</ul>
<p>Most of the time, I&#39;ve found that the command prompt session trying to run the storage emulator wasn&#39;t running as an Administrator. Here&#39;s how to fix that problem:</p>
<p>Open an Administrator command prompt by opening the start menu, typing <code>cmd</code>, right-clicking on the Command Prompt app, and selecting <em>Run as administrator</em>.</p>
<p><img src="images/chapter3/admin-cmd.gif" alt="image"></p>
<p>Change into the <code>C:\Program Files (x86)\Microsoft SDKs\Azure\Storage Emulator</code> folder:</p>
<pre><code>cd &quot;C:\Program Files (x86)\Microsoft SDKs\Azure\Storage Emulator&quot;
</code></pre><p>Run the <code>AzureStorageEmulator.exe start</code> command to start the storage emulator:</p>
<pre><code>AzureStorageEmulator.exe start
</code></pre><p>The storage emulator should start.</p>
<p><img src="images/chapter3/emulator-start.png" class="img-medium" /></p>
<div class="exercise-end"></div>

<h3 id="using-storage-explorer">Using Storage Explorer</h3>
<p>After the the Azure Storage Emulator is running, let&#39;s turn our attention to <a href="http://storageexplorer.com">Storage Explorer</a>. Storage Explorer is a standalone app from Microsoft that allows you to easily work with Azure Storage Accounts on Windows, macOS and Linux.</p>
<p>We&#39;ll be using Storage Explorer throughout the workshop to peek into the local storage account (created by the Storage Emulator) and Azure-hosted storage account. </p>
<p>Let&#39;s get started!</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Starting up the Azure Storage Emulator
</h4>

<p>You&#39;ll find Storage Explorer in your start menu. Open the start menu, type in storage, and look for <em>Microsoft Azure Storage Explorer</em> under the <em>Apps</em> section:</p>
<p><img src="images/chapter3/storage-explorer-launch.gif" alt="image"></p>
<p>When Storage Explorer launches for the first time, you&#39;ll be prompted to connect to Azure Storage:</p>
<p><img src="images/chapter3/azure-prompt.png" alt="image"></p>
<p>Click <em>Sign In</em> and enter your Azure account credentials. </p>
<p><img src="images/chapter3/sign-in.png" alt="image"></p>
<p>After entering your credentials, you&#39;ll see a list of Azure subscriptions associated with your account. NOTE: You can have multiple subscriptions linked to your account (like mine), or just one.</p>
<p>Check the box next to the subscription you want to use. Press <em>Apply</em>.</p>
<p><img src="images/chapter3/azure-subs.png" alt="image"></p>
<p>On the left-hand side, you&#39;ll see a list of azure subscriptions and local storage accounts. Locate the local storage account named <em>(Local and Attached)</em>. Drill down to <em>Storage Accounts</em> -&gt; <em>(Development)</em> -&gt; <em>Tables</em>.</p>
<p>Take note there are no tables in your local storage account.</p>
<p><img src="images/chapter3/local-storage.gif" alt="image"></p>
<p>Congratulations! That&#39;s how easy it is to use Storage Explorer. We&#39;ll come back to Storage Explorer in a few minutes.</p>
<p>Head back to Visual Studio and run your web app. </p>
<p><img src="images/chapter3/launch-web-app.png" class="img-small" /></p>
<p>If you&#39;ve made all the changes to your app successfully, the app should start up, and you&#39;ll be greeted with the default ASP.NET MVC template page again. </p>
<p>But, something will be different this time. You&#39;ll recall that we&#39;ve swapped out Entity Framework and SQL Server in lieu of Azure Table Storage. You&#39;ll also recall that we configured the app to create the necessary tables needed for ASP.NET Identity on app startup. </p>
<p>Let&#39;s check back in Storage Emulator to see the tables created:</p>
<p><img src="images/chapter3/local-storage-with-tables.gif" alt="image"></p>
<p>You should now see the <em>AspNetIndex</em>, <em>AspNetRoles</em>, and <em>AspNetUsers</em> tables. </p>
<div class="exercise-end"></div>

<h3 id="testing-it-out">Testing it out</h3>
<p>Now that everything is running, let&#39;s test it out by registering a new user.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Register a user
</h4>

<p>Click the <em>Register</em> link in the upper-right corner of the app. Enter in an email and password. Press the <em>Register</em> button to create the user.</p>
<p><img src="images/chapter3/register.png" alt="image"></p>
<p>After registering, you&#39;re automatically logged in as that user. Take a minute to explore your user profile by clicking on your name in the upper-right. </p>
<p><img src="images/chapter3/view-profile.png" alt="image"></p>
<p>We&#39;ll be coming back to this profile page throughout the workshop, modifying it to add a profile picture and a biography.</p>
<p><img src="images/chapter3/manage-profile.png" class="img-medium" /></p>
<p>After registering the user, let&#39;s look back at Storage Explorer. Select the <em>AspNetUsers</em> table and view the contents of the table in the right-side panel. </p>
<blockquote>
<p><strong>NOTE</strong> You may need to press the <em>Refresh</em> button to load the data into the table.</p>
</blockquote>
<p><img src="images/chapter3/table-data.gif" class="img-large" /></p>
<div class="exercise-end"></div>

<p>That&#39;s it for chapter 3. In the next chapter, you&#39;ll learn how to connect the web app to an Azure-hosted Table Storage account.</p>

			</div>
			<hr>
			<div class="chapter">
				<h2 id="connecting-the-app-to-azure">Connecting the app to Azure</h2>
<p>In this chapter, you&#39;ll be learning how to create an Azure storage account and connect the web app we created in chapters 2 and 3 to the storage account.</p>
<h3 id="creating-a-resource-group">Creating a Resource Group</h3>
<p>Our first stop will be to create a Resource Group in Azure. </p>
<blockquote>
<p><strong>DEFINITION</strong> Formally, resource groups provide a way to monitor, control access, provision and manage billing for collections of assets that are required to run an application, or used by a client or company department. Informally, think of resource groups like a file system folder, but instead of holding files and other folders, resource groups hold azure objects like storage accounts, web apps, functions, etc.</p>
</blockquote>
<h4 class="exercise-start">
    <b>Exercise</b>: Create a Dashboard and Resource Group
</h4>

<h4 id="creating-a-dashboard">Creating a Dashboard</h4>
<p>We&#39;ll start by creating a dashboard. </p>
<p>Login to the Azure portal, click <em>+ New Dashboard</em>, give the dashboard name, and click <em>Done customizing</em>.</p>
<p><img src="images/chapter4/create-dashboard.gif" class="img-medium" /></p>
<p>That was easy! Dashboards are a quick way of organizing your Azure services. We like to create one for the workshop because it helps keep everything organized. You&#39;ll have a single place to go to find everything you build today.</p>
<h4 id="creating-a-resource-group">Creating a Resource Group</h4>
<p>Next, we&#39;ll create a resource group to hold the various services we&#39;ll be creating today. </p>
<p>Click the <em>+ New</em> button on the left.</p>
<p><img src="images/chapter4/new.png" alt="image"></p>
<p>Search for resource group by using the search box, selecting <em>Resource Group</em> when it appears.</p>
<p><img src="images/chapter4/new-resource.png" alt="image"></p>
<p>Select <em>Resource Group</em> from the search results window:</p>
<p><img src="images/chapter4/resource-group-results.png" alt="image"></p>
<p>Click <em>Create</em> at the bottom:</p>
<p><img src="images/chapter4/create-resource-group.png" alt="image"></p>
<p>Give the Resource group a name, select your Azure subscription, and a location. Also CHECK the <em>Pin to Dashboard</em> option. Press <em>Create</em> when you&#39;re finished.</p>
<p><img src="images/chapter4/create-resource-group-2.png" alt="image"></p>
<p>After it&#39;s created, it will be open in Azure automatically:</p>
<p><img src="images/chapter4/resource-group-created.png" alt="image"></p>
<p>Close the resource group by clicking the <em>X</em> in the upper-right corner. Note that the resource group has been added to your dashboard.</p>
<p><img src="images/chapter4/resource-group-dashboard.png" alt="image"></p>
<p>Form the dashboard, you can click on the resource group to re-open it at any time.</p>
<div class="exercise-end"></div>

<p>That wraps up the basics of creating resource groups. We&#39;re not going to take a deep dive into Azure Resource Group. If you&#39;re interested in learning more, check out this <a href="https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-portal">article</a>.</p>
<h3 id="creating-a-storage-account">Creating a Storage Account</h3>
<p>Our next stop is at Storage Accounts. You&#39;ll recall from the last chapter that storage accounts are the topmost Azure service that contains other resources such as the blob storage, file storage, queue storage, and table storage services.</p>
<p>Before we can store data to an Azure table, we&#39;ll need to create a storage account.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Create a Storage Account
</h4>

<p>Return to your dashboard if you&#39;re not already there. Click <em>+ New</em>, select <em>Storage</em> from the list of service categories, and select <em>Storage account - blob, file, table, queue</em>.</p>
<p><img src="images/chapter4/create-storage-account.gif" class="img-medium" /></p>
<p>Complete the following fields:</p>
<ul>
<li><strong>Name:</strong> this must be a unique, URL-friendly name that will be prepended to the URL <code>{storage-account-name}.core.windows.net</code>. You&#39;ll use this full URL name to reference the storage account in code</li>
<li><strong>Deployment model:</strong> Resource manager. The <em>Classic</em> option is a legacy option that will be deprecated soon. Don&#39;t pick it. Choosing the <em>Resource manager</em> options also allows you to create automation scripts for provisioning Azure resources easily</li>
<li><strong>Account kind:</strong> General purpose. You can create an account that stores only blobs (binary large objects), but for our workshop we want a storage account that can store both tables and blobs</li>
<li><strong>Performance:</strong> Standard, because our needs are simple. If you were an enterprise, you may want to choose Premium for the enhanced SLA and scalability. To learn more about the difference, check out this <a href="https://docs.microsoft.com/en-us/azure/storage/storage-introduction#introducing-the-azure-storage-services">article</a></li>
<li><strong>Replication:</strong> Locally-redundant storage (LRS). The data in your Microsoft Azure storage account is always replicated to ensure durability and high availability. Replication copies your data, either within the same data center, or to a second data center, depending on which replication option you choose. Replication protects your data and preserves your application up-time in the event of transient hardware failures. If your data is replicated to a second data center, that also protects your data against a catastrophic failure in the primary location. To learn more read this <a href="https://docs.microsoft.com/en-us/azure/storage/storage-redundancy">article</a>.</li>
<li><strong>Storage service encryption:</strong> Disabled. Azure Storage Service Encryption (SSE) for Data at Rest helps you protect and safeguard your data to meet your organizational security and compliance commitments. With this feature, Azure Storage automatically encrypts your data prior to persisting to storage and decrypts prior to retrieval. The encryption, decryption, and key management are totally transparent to users. To learn more, read this <a href="https://docs.microsoft.com/en-us/azure/storage/storage-service-encryption">article</a>.</li>
<li><strong>Subscription:</strong> Select your subscription.</li>
<li><strong>Resource group:</strong> Use existing and select the resource group you just created. By selecting the existing resource group, the storage account will be added to the resource group. This makes it easier to manage.</li>
<li><strong>Location:</strong> East US</li>
<li><strong>PIN to dashboard:</strong> Yes</li>
</ul>
<p><img src="images/chapter4/storage-account-options.png" alt="image"></p>
<p>After you create the Storage account, you&#39;ll be brought back to your dashboard and presented with a deployment placeholder:</p>
<p><img src="images/chapter4/storage-account-placeholder.png" class="img-small" /></p>
<p>All Azure services deployed with the Resource Manager option are deployed in an asynchronous manner.</p>
<p>When the storage account is provisioned, it will open up in the portal. </p>
<p><img src="images/chapter4/storage-account-provisioned.png" class="img-large" /></p>
<p>From the storage account details pages, you can explore the contents of blobs, files, tables, and queues. The experience is similar to that of storage explorer.</p>
<p><img src="images/chapter4/exploring-storage-account.gif" class="img-large" /></p>
<div class="exercise-end"></div>

<h3 id="accessing-a-storage-account-in-storage-explorer">Accessing a Storage Account in Storage Explorer</h3>
<p>Now that you&#39;ve added a storage account to your Azure Subscription, let&#39;s check it out in Storage Explorer.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Viewing an Azure-hosted Storage Account in Storage Explorer 
</h4>

<p>In a previous step, we added our Azure subscription to Storage Explorer. Before continuing, ensure your subscription has been added. </p>
<p>Return to Storage Explorer and press the <em>Refresh All</em> link. You should see the storage account appear underneath your Azure subscription. You&#39;ll recall my storage account was named <em>globalazurelouisville</em>:</p>
<p><img src="images/chapter4/refresh.png" alt="image"></p>
<p>Expand the storage account, then the <em>Tables</em> item to verify no tables have been created.</p>
<p><img src="images/chapter4/no-tables.png" alt="image"></p>
<div class="exercise-end"></div>

<p>Great work! Now that we&#39;ve provisioned a storage account and we can access it from Storage Explorer, it&#39;s time to start using it. In this next exercise, you&#39;ll obtain connection information from the storage account and add it to your web app.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Getting a Storage Account Connection String 
</h4>

<p>In an earlier chapter, you replaced Entity Framework with the El Camino package, so our web app could use Azure Table Storage to persist user information via ASP.NET Identity. As part of that process, several lines we added to the <code>web.config</code> file:</p>
<pre><code class="lang-xml">&lt;configSections&gt;
    &lt;section name=&quot;elcaminoIdentityConfiguration&quot; type=&quot;ElCamino.AspNet.Identity.AzureTable.Configuration.IdentityConfigurationSection,ElCamino.AspNet.Identity.AzureTable &quot; /&gt;
&lt;/configSections&gt;
&lt;elcaminoIdentityConfiguration tablePrefix=&quot;&quot; storageConnectionString=&quot;UseDevelopmentStorage=true&quot; /&gt;
&lt;!--&lt;elcaminoIdentityConfiguration tablePrefix=&quot;&quot; storageConnectionString=&quot;DefaultEndpointsProtocol=https;AccountName=STORAGE_ACCOUNT_NAME;AccountKey=STORAGE_ACCOUNT_KEY;&quot; /&gt;--&gt;
</code></pre>
<p>Take a closer look at the <code>&lt;elcaminoIdentityConfiguration&gt;</code> element:</p>
<pre><code class="lang-xml">&lt;elcaminoIdentityConfiguration tablePrefix=&quot;&quot; storageConnectionString=&quot;UseDevelopmentStorage=true&quot; /&gt;
</code></pre>
<p>This element contains a storage account connection string. Similar to SQL Server databases, storage accounts have a connection string. And, similar to local SQL server installations (like localdb), locally-hosted storage emulators have a special connection string.</p>
<p>When you&#39;re developing locally, the connection string is <code>UserDevelopmentStorage=true</code>.</p>
<p>But, when we move to the cloud, the connection string has an enhanced structure containing 3 components: </p>
<ul>
<li><strong>Default Endpoints Protocol:</strong> the communication protocol used to talk to the remote table storage. By default it&#39;s https, and there&#39;s truthfully no reason for you to change it.</li>
<li><strong>Account Name:</strong> the name you gave the account.</li>
<li><strong>Account Key:</strong> a secret key that you shouldn&#39;t share with others. Treat it like a super user password.</li>
</ul>
<p>You can see this structure in the commented-out section of the <code>web.config</code> from above:</p>
<pre><code class="lang-xml">&lt;elcaminoIdentityConfiguration tablePrefix=&quot;&quot; storageConnectionString=&quot;DefaultEndpointsProtocol=https;AccountName=STORAGE_ACCOUNT_NAME;AccountKey=STORAGE_ACCOUNT_KEY;&quot; /&gt;
</code></pre>
<p>Let&#39;s update our web app to use the Azure-hosted storage account we just created. Comment-out the development configuration element and uncomment the element with the Azure-hosted connection string.</p>
<pre><code class="lang-xml">&lt;configSections&gt;
    &lt;section name=&quot;elcaminoIdentityConfiguration&quot; type=&quot;ElCamino.AspNet.Identity.AzureTable.Configuration.IdentityConfigurationSection,ElCamino.AspNet.Identity.AzureTable &quot; /&gt;
&lt;/configSections&gt;
&lt;!--&lt;elcaminoIdentityConfiguration tablePrefix=&quot;&quot; storageConnectionString=&quot;UseDevelopmentStorage=true&quot; /&gt;--&gt;
&lt;elcaminoIdentityConfiguration tablePrefix=&quot;&quot; storageConnectionString=&quot;DefaultEndpointsProtocol=https;AccountName=STORAGE_ACCOUNT_NAME;AccountKey=STORAGE_ACCOUNT_KEY;&quot; /&gt;
</code></pre>
<p>Replace <code>STORAGE_ACCOUNT_NAME</code> with the name of the storage account you created in the previous steps. Ours looks like:</p>
<pre><code class="lang-xml">&lt;elcaminoIdentityConfiguration tablePrefix=&quot;&quot; storageConnectionString=&quot;DefaultEndpointsProtocol=https;AccountName=globalazurelouisville;AccountKey=STORAGE_ACCOUNT_KEY;&quot; /&gt;
</code></pre>
<p>The last step is to get our storage account key, replacing the <code>STORAGE_ACCOUNT_KEY</code> placeholder int he <code>web.config</code>. Luckily, Storage Explorer makes this simple.</p>
<p>Go back to Storage Explorer, right-click the storage account name, selecting <em>Copy Primary Key</em>.</p>
<p><img src="images/chapter4/copy-primary-key.gif" alt="image"></p>
<p>This copies the primary storage account key to your clipboard. Paste the key into your <code>web.config</code>, replacing <code>STORAGE_ACCOUNT_KEY</code> with the value from your clipboard. </p>
<div class="exercise-end"></div>

<h3 id="testing-with-azure-table-storage">Testing with Azure Table Storage</h3>
<p>Now that you&#39;ve updated the <code>web.config</code> to point to an Azure storage account, let&#39;s re-launch the web app and test it out!</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Testing the updated web app
</h4>

<p>When the web app launches, register a user. </p>
<blockquote>
<p><strong>NOTE</strong> You may recall that you previously registered a user with the app, but we&#39;ve just told the app to use a different storage account for ASP.NET Identity. This means you&#39;ll have to re-register the user.</p>
</blockquote>
<p>Click the <em>Register</em> link in the upper-right corner of the app. Enter in an email and password. Press the <em>Register</em> button to create the user.</p>
<p><img src="images/chapter3/register.png" alt="image"></p>
<p>As a final check, refresh the Azure storage account in Storage Explorer, verifying that the <em>AspNetIndex</em>, <em>AspNetRoles</em>, and <em>AspNetUsers</em> tables were created and your registered user appears in the <em>AspNetUsers</em> table.</p>
<p><img src="images/chapter4/verify.gif" class="img-large" /></p>
<div class="exercise-end"></div>

<p>Congratulations!</p>
<p>You just built a highly-scalable, secure, centralized, single-sign on system. That&#39;s right. The storage account you just created and attached to ASP.NET Identity can be shared across applications: just reuse the connection string in your next app. And the best part - it took ~45 minutes. Bam!</p>
<p>Pretty impressive.</p>
<h3 id="understanding-app-service-and-web-apps">Understanding App Service and Web Apps</h3>
<p>In the last part of this chapter, you&#39;ll learn how to create an Azure Web App and deploy our solution to the cloud. In short, I like to think of Azure Web Apps like IIS in the cloud, but without the pomp and circumstance of setting up and configuring IIS.</p>
<p>Web Apps are also part of a larger Azure service called the App Service, which is focused on helping you to build highly-scalable cloud apps focused on the web (via Web Apps), mobile (via Mobile Apps), APIs (via API Apps), and automated business processes (via Logic Apps). </p>
<p>We don&#39;t have time to fully explore all of the components of the Azure App Service, so if you&#39;re interested, you can read more <a href="https://azure.microsoft.com/en-us/services/app-service/">online</a>.</p>
<h4 id="what-is-an-azure-web-app-">What is an Azure Web App?</h4>
<p>As we&#39;ve mentioned, Web Apps are like IIS in the cloud, but calling it that seems a bit unfair because there&#39;s quite a bit more to  Web Apps:</p>
<ul>
<li><p><strong>Websites and Web Apps:</strong> Web Apps let developers rapidly build, deploy, and manage powerful websites and web apps. Build standards-based web apps and APIs using .NET, Node.js, PHP, Python, and Java. Deliver both web and mobile apps for employees or customers using a single back end. Securely deliver APIs that enable additional apps and devices.</p>
</li>
<li><p><strong>Familiar and fast:</strong> Use your existing skills to code in your favorite language and IDE to build APIs and apps faster than ever. Access a rich gallery of pre-built APIs that make connecting to cloud services like Office 365 and Salesforce.com easy. Use templates to automate common workflows and accelerate your development. Experience unparalleled developer productivity with continuous integration using Visual Studio Team Services, GitHub, and live-site debugging.</p>
</li>
<li><p><strong>Enterprise grade:</strong> App Service is designed for building and hosting secure mission-critical applications. Build Azure Active Directory-integrated business apps that connect securely to on-premises resources, and then host them on a secure cloud platform that&#39;s compliant with ISO information security standard, SOC2 accounting standards, and PCI security standards. Automatically back up and restore your apps, all while enjoying enterprise-level SLAs.</p>
</li>
<li><p><strong>Build on Linux or bring your own Linux container image:</strong> Azure App Service provides default containers for versions of Node.js and PHP that make it easy to quickly get up and running on the service. With our new container support, developers can create a customized container based on the defaults. For example, developers could create a container with specific builds of Node.js and PHP that differ from the default versions provided by the service. This enables developers to use new or experimental framework versions that are not available in the default containers.</p>
</li>
<li><p><strong>Global scale:</strong> App Service provides availability and automatic scale on a global datacenter infrastructure. Easily scale applications up or down on demand, and get high availability within and across different geographical regions. Replicating data and hosting services in multiple locations is quick and easy, making expansion into new regions and geographies as simple as a mouse click.</p>
</li>
<li><p><strong>Optimized for DevOps:</strong> Focus on rapidly improving your apps without ever worrying about infrastructure. Deploy app updates with built-in staging, roll-back, testing-in-production, and performance testing capabilities. Achieve high availability with geo-distributed deployments. Monitor all aspects of your apps in real-time and historically with detailed operational logs. Never worry about maintaining or patching your infrastructure again.</p>
</li>
</ul>
<h3 id="deploying-to-a-web-app-from-visual-studio">Deploying to a Web App from Visual Studio</h3>
<p>Now that you understand the basics of web apps, let&#39;s create one and deploy our app to the cloud! </p>
<p>Earlier in this chapter, we created a storage account in Azure via the Azure portal. You can also create Web Apps via the Azure portal in the same manner. But, we&#39;re going to show you another way of creating a Web App: from Visual Studio.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Deploying to a Web App from Visual Studio 2017
</h4>

<blockquote>
<p><strong>NOTE:</strong> This exercise assumes you&#39;re running Visual Studio 2017. The UI and screens in Visual Studio 2015 aren&#39;t the same, but similar. We&#39;re not going to include screen shots for 2015, but we think you can figure it out.</p>
</blockquote>
<p>From Visual Studio, right-click the <em>Web</em> project and select <em>Publish</em>. In the web publish window, select <em>Microsoft Azure App Service</em>, <em>Create New</em>, and press <em>Publish</em>. This short clip walks you through the process:</p>
<p><img src="images/chapter4/publish-web-app.gif" class="img-large" /></p>
<p>On the next page, give your Web App a name, select your Azure subscription, and select the Resource Group you created earlier (mine was named Global-Azure-Louisville-2017).</p>
<p><img src="images/chapter4/web-app-settings.png" class="img-medium" /></p>
<p>Click <em>New...</em> to create a new Web App plan.</p>
<blockquote>
<p><strong>NOTE</strong> Web App plans describe the performance needs of a web app. Plans range from free (where multiple web apps run on shared hardware) to not-so-free, where you have dedicated hardware, lots of processing power, RAM, and SSDs. To learn more about the various plans, check out this <a href="https://azure.microsoft.com/en-us/pricing/details/app-service/plans/">article</a>.</p>
</blockquote>
<p>Create a new free plan.</p>
<p><img src="images/chapter4/new-plan.png" class="img-medium" /></p>
<p>After the plan is created, click <em>Create</em> to create the Web App in Azure.</p>
<p><img src="images/chapter4/deploying.gif" class="img-large" /></p>
<p>When the Azure Web App is created in Azure, Visual Studio will publish the app to the Web App. after the publish has finished, you should see something similar:</p>
<p><img src="images/chapter4/published.png" class="img-large" /></p>
<p>Finally, Visual Studio will launch the site in your browser, showing you your deployed site.</p>
<div class="exercise-end"></div>

<p>Well done. You&#39;ve reached the end of chapter 4. If you&#39;ve been following along, you have learned:</p>
<ul>
<li>How to create dashboards and resource groups in the Azure portal</li>
<li>How to create a storage account for blobs, files, tables, and queues</li>
<li>How to view the contents of a storage account with Storage Explorer</li>
<li>What a storage account connection string looks like</li>
<li>How to create a Web App from Visual Studio and deploy to it</li>
</ul>

			</div>
			<hr>
			<div class="chapter">
				<h2 id="adding-a-custom-field-to-aspnet-identity">Adding a custom field to AspNet Identity</h2>
<p>In the previous chapters, you learned how to persist ASP.NET Identity user information in Azure Table Storage. You also learned how to use a locally-hosted storage emulator so you can develop without connecting the cloud. </p>
<p>In this chapter, we&#39;ll continue to update our web app by adding a custom field to the user&#39;s profile. </p>
<h3 id="visualizing-what-you-re-building">Visualizing What You&#39;re Building</h3>
<p>Before we jump in, let&#39;s take a minute to visualize what you&#39;ll be building. </p>
<p><img src="images/chapter5/manage-biography.gif" class="img-large" /></p>
<p>The ASP.NET MVC template starts with a profile management page that allows you to change your password, manage alternate logins (such as Facebook, Twitter, Microsoft, etc.), and configure multi-factor authentication (if enabled).</p>
<p>We&#39;ll be adding the <em>Biography</em> field. Once added, you&#39;ll be able to see your biography on the main page and navigate to a second page to update the biography. </p>
<p>You may also notice the status message that is shown when the biography has been updated. </p>
<p><img src="images/chapter5/message.png" alt="image"></p>
<p>Let&#39;s get started! We&#39;ll begin by modifying ASP.NET Identity to include the new field, then move on to modifying the MVC code.</p>
<h3 id="extending-asp-net-identity">Extending ASP.NET Identity</h3>
<p>If you ever used the old ASP.NET Membership Provider, you&#39;ll remember how painful it was to extend it. Extending ASP.NET Identity is different: it&#39;s easy.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Extending ASP.NET Identity with a Biography
</h4>

<p>To extend ASP.NET Identity, add two things:</p>
<ol>
<li>public property to the <code>ApplicationUser</code> class</li>
<li>async accessor function for the property to the <code>ApplicationUserManager</code> class</li>
</ol>
<h4 id="updating-the-applicationuser-class">Updating the <code>ApplicationUser</code> class</h4>
<p>Add a public property to the <code>ApplicationUser</code> class, located in the the <em>IdentityModel.cs</em> file. You can find this file in the <em>Models</em> folder.</p>
<p>You&#39;ll remember this is the class that inherits from <code>IdentityUser</code>, the class ASP.NET Identity uses to represent a user. </p>
<pre><code class="lang-csharp">public string Biography { get; set; }
</code></pre>
<h4 id="updating-the-applicationusermanager-class">Updating the <code>ApplicationUserManager</code> class</h4>
<p>Add an asynchronous accessor function to the <code>ApplicationUserManager</code> class. The method will take a <code>userId</code> and return the user&#39;s biography. You can find the <code>ApplicationUserManager</code> class in the <em>IdentityConfig.cs</em> file, located in the <em>App_Start</em> folder.</p>
<p>Add this code after the constructor.</p>
<pre><code class="lang-csharp">public async Task&lt;string&gt; GetBiographyAsync(string userId)
{
    var user = await this.Store.FindByIdAsync(userId);
    return (user != null) ? user.Biography : string.Empty;
}
</code></pre>
<p>This function uses the <code>Store</code> object, which is of type <code>IUserStore&lt;ApplicationUser&gt;</code>, which (simply put) is the object that manages storing and retrieving user data from our Azure table. </p>
<p>The <code>this.Store.FindByIdAsync(userId)</code> call gets a reference to our user. We then return the user&#39;s biography, or an empty string if the user isn&#39;t found.</p>
<div class="exercise-end"></div>

<p>And, that&#39;s it. Pretty simple. That&#39;s all you need to do to extend ASP.NET Identity with a new property. </p>
<h3 id="updating-mvc-code-to-support-the-biography-property">Updating MVC code to Support the Biography Property</h3>
<p>Now that you&#39;ve added the property, let&#39;s update the MVC models, views, and controller actions to support the addition of the biography property.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Updating the MVC code to support the biography property
</h4>

<p>This exercise is a bit longer than others, because we&#39;ll be updating a lot of files. At a high level, we&#39;ll be adding the biography property to our web app in several steps. </p>
<p>We&#39;ll start with the profile management page, which will show the biography and a link to update the biography:</p>
<ul>
<li><strong>Step 1:</strong> Update the <code>IndexViewModel</code> in <em>ManageViewModels.cs</em></li>
<li><strong>Step 2:</strong> Update the Manage\Index view </li>
</ul>
<p>Then we&#39;ll move on to a new page that updates the biography:</p>
<ul>
<li><strong>Step 3:</strong> Create the <code>UpdateBiographyViewModel</code> class in <em>ManageViewModels.cs</em></li>
<li><strong>Step 4:</strong> Create the Update Biography view</li>
<li><strong>Step 5:</strong> Add a GET controller action for the Update Biography view to <em>ManageController.cs</em></li>
<li><strong>Step 6:</strong> Add a &quot;Your biography was updated&quot; message to <em>ManageController.cs</em></li>
<li><strong>Step 7:</strong> Add a POST controller action for the Update Biography view to <em>ManageController.cs</em></li>
</ul>
<p>Finally, we&#39;ll return to the profile management page:</p>
<ul>
<li><strong>Step 8:</strong> Update the GET controller action for the Index view in <em>ManageController.cs</em> to populate the view with the updated biography</li>
</ul>
<p>There&#39;s a lot to do, so let&#39;s get moving!</p>
<h4 id="-step-1-update-the-indexviewmodel-in-manageviewmodels-cs-"><strong>Step 1:</strong> Update the <code>IndexViewModel</code> in <em>ManageViewModels.cs</em></h4>
<p>Start by updating the <code>IndexViewModel</code> class. Add a property for the biography.</p>
<pre><code class="lang-csharp">public class IndexViewModel
{
    public bool HasPassword { get; set; }
    public IList&lt;UserLoginInfo&gt; Logins { get; set; }
    public string PhoneNumber { get; set; }
    public bool TwoFactor { get; set; }
    public bool BrowserRemembered { get; set; }
    public string Biography { get; set; }
}
</code></pre>
<blockquote>
<p>Adding this property will allow the index view to display the biography when it loads. We&#39;ll be setting the value of the biography later in this exercise when we update the index controller&#39;s GET action.</p>
</blockquote>
<h4 id="-step-2-update-the-manage-index-view"><strong>Step 2:</strong> Update the Manage\Index view</h4>
<p>Update <em>Index.cshtml</em> in the <em>Views\Manage</em> folder to display:</p>
<ul>
<li>Biography heading</li>
<li>Biography value</li>
<li>Link to update the Biography</li>
</ul>
<p>Add the Razor markup as the first child element of the <code>&lt;dl class=&quot;dl-horizontal&quot;&gt;</code> element:</p>
<pre><code class="lang-html">&lt;dt&gt;Biography:&lt;/dt&gt;
&lt;dd&gt;
    @Model.Biography
    [
    @Html.ActionLink(&quot;Update your biography&quot;, &quot;UpdateBiography&quot;)
    ]
&lt;/dd&gt;
</code></pre>
<p>The HTML action link will render as an HTML link to the Update Biography view (which we&#39;ll create next).</p>
<h4 id="-step-3-create-the-updatebiographyviewmodel-class-in-manageviewmodels-cs-"><strong>Step 3:</strong> Create the <code>UpdateBiographyViewModel</code> class in <em>ManageViewModels.cs</em></h4>
<p>Add a new view model class named <code>UpdateBiographyViewModel</code> in the <em>ManageViewModels.cs</em> file. This view model will be used to view and update a user&#39;s biography from the Update Biography view.</p>
<pre><code class="lang-csharp">public class UpdateBiographyViewModel
{
    [Display(Name = &quot;Biography&quot;)]
    public string Biography { get; set; }
}
</code></pre>
<h4 id="-step-4-create-the-update-biography-view"><strong>Step 4:</strong> Create the Update Biography view</h4>
<p>Create a view named <code>UpdateBiography.cshtml</code> in the <em>Views\Manage</em> folder. This view will use the previously created <code>UpdateBiographyViewModel</code> to show and update a user&#39;s biography.</p>
<pre><code class="lang-html">@model Web.Models.UpdateBiographyViewModel
@{
    ViewBag.Title = &quot;Biography&quot;;
}

&lt;h2&gt;@ViewBag.Title&lt;/h2&gt;

@using (Html.BeginForm(&quot;UpdateBiography&quot;, &quot;Manage&quot;, FormMethod.Post, new { @class = &quot;form-horizontal&quot;, role = &quot;form&quot;, enctype = &quot;multipart/form-data&quot; }))
{
    @Html.AntiForgeryToken()
    &lt;h4&gt;Update your biography&lt;/h4&gt;
    &lt;hr /&gt;
    @Html.ValidationSummary(&quot;&quot;, new { @class = &quot;text-danger&quot; })
    &lt;div class=&quot;form-group&quot;&gt;
        @Html.LabelFor(m =&gt; m.Biography, new { @class = &quot;col-md-2 control-label&quot; })
        &lt;div class=&quot;col-md-10&quot;&gt;
            @Html.TextBoxFor(m =&gt; m.Biography, new { @class = &quot;form-control&quot; })
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;div class=&quot;col-md-offset-2 col-md-10&quot;&gt;
            &lt;input type=&quot;submit&quot; class=&quot;btn btn-default&quot; value=&quot;Submit&quot; /&gt;
        &lt;/div&gt;
    &lt;/div&gt;
}

@section Scripts {
    @Scripts.Render(&quot;~/bundles/jqueryval&quot;)
}
</code></pre>
<h4 id="-step-5-add-a-get-controller-action-for-the-update-biography-view-to-managecontroller-cs-"><strong>Step 5:</strong> Add a GET controller action for the Update Biography view to <em>ManageController.cs</em></h4>
<p>Now that the model and view are created, add a GET controller action to the <em>ManageController.cs</em> file to show the Update Biography view.</p>
<pre><code class="lang-csharp">//
// Get: /Manage/UpdateBiography
public async Task&lt;ActionResult&gt; UpdateBiography()
{
    var userId = User.Identity.GetUserId();
    var updateBiographyViewModel = new UpdateBiographyViewModel()
    {
        Biography = await UserManager.GetBiographyAsync(userId) 
    };

    return View(updateBiographyViewModel);
}
</code></pre>
<p>You may not immediately recognize all of the code you just added, so let&#39;s break it down. First, we grab the current user&#39;s id by calling into ASP.NET Identity with <code>User.Identity.GetUserId()</code>. With the user&#39;s id, we call the function we created earlier in this chapter (<code>GetBiographyAsync()</code>) to load the user&#39;s biography. </p>
<p>The retrieved biography is then used to construct a model passed back to the Update Biography view.</p>
<h4 id="-step-6-add-a-your-biography-was-updated-message-to-managecontroller-cs-"><strong>Step 6:</strong> Add a &quot;Your biography was updated&quot; message to <em>ManageController.cs</em></h4>
<p>Now that we have the Update Biography view showing a user&#39;s biography, let&#39;s start planning what happens when a user&#39;s biography is updated. </p>
<p>When the biography is updated, the POST controller action will be called and the user will be redirected back to the Manage\Index view. We&#39;ll get to this next. </p>
<p>When you return to the Manage\Index view, a message reading, &quot;Your biography was updated&quot; is also displayed. This is done by passing a specially-formatted query string value back to the view via the <code>ManageMessageId</code> enum. </p>
<p>Update the enum to include a value for <code>UpdateBiographySuccess</code>. </p>
<blockquote>
<p><strong>NOTE</strong> You may have trouble finding the enum declaration because it&#39;s hidden behind a collapsed region labeled <em>Helpers</em>. Scroll down to the bottom of the <em>ManageController.cs</em> class to find the region. Expand it and you&#39;ll be able to locate the enum.</p>
</blockquote>
<pre><code class="lang-csharp">public enum ManageMessageId
{
    AddPhoneSuccess,
    ChangePasswordSuccess,
    SetTwoFactorSuccess,
    SetPasswordSuccess,
    RemoveLoginSuccess,
    RemovePhoneSuccess,
    Error,
    UpdateBiographySuccess
}
</code></pre>
<h4 id="-step-7-add-a-post-controller-action-for-the-update-biography-view-to-managecontroller-cs-"><strong>Step 7:</strong> Add a POST controller action for the Update Biography view to <em>ManageController.cs</em></h4>
<p>Add a POST controller action to the Manage controller, using the <code>UpdateBiographySuccess</code> enum value just created.</p>
<pre><code class="lang-csharp">[HttpPost]
[ValidateAntiForgeryToken]
public async Task&lt;ActionResult&gt; UpdateBiography(UpdateBiographyViewModel model)
{
    if (!ModelState.IsValid)
    {
        return View(model);
    }
    var user = await UserManager.FindByIdAsync(User.Identity.GetUserId());
    if (user != null)
    {
        user.Biography = model.Biography;
        await UserManager.UpdateAsync(user);
    }
    return RedirectToAction(&quot;Index&quot;, new { Message = ManageMessageId.UpdateBiographySuccess });
}
</code></pre>
<p>Much of the code is straight-forward, but we want to draw your attention to a few lines, starting with <code>var user = await UserManager.FindByIdAsync(User.Identity.GetUserId());</code>. You&#39;ve already seen the <code>GetUserId()</code> function, but you haven&#39;t directly worked with the <code>UserManager</code> class. </p>
<blockquote>
<p><strong>NOTE</strong> The <code>UserManager</code> class, well, manages users. That sounds redundant, but we like to think of it as a user repository. If you&#39;re not familiar with the repository pattern, Martin Fowler has an excellent article on [repositories] online. Check it out. </p>
</blockquote>
<p>Back to the code. Because <code>UserManager</code> acts as a repository, we use it to retrieve a user object (more specifically, the <code>ApplicationUser</code> object which inherits from <code>IdentityUser</code>). Once we have the user, we update the biography property and send the user back through the repository to be persisted: <code>await UserManager.UpdateAsync(user);</code>.</p>
<p>After the user is saved, you&#39;re redirected back to the Manage\Index view, passing the <code>UpdateBiographySuccess</code> enum value as a query string parameter.</p>
<h4 id="-step-8-update-the-get-controller-action-for-the-index-view-in-managecontroller-cs-"><strong>Step 8:</strong> Update the GET controller action for the Index view in <em>ManageController.cs</em></h4>
<p>The final step is to update the GET controller action of the Manage\Index view. Below is the entire function, but note the added line setting the <code>ViewBag.StatusMessage</code> to &quot;Your biography was updated.&quot; when the <code>ManageMessageId</code> enum has a value of <code>UpdateBiographySuccess</code>. </p>
<p>You should also note that the index view model&#39;s biography property is set by calling the method you created earlier: <code>UserManager.GetBiographyAsync(userId)</code>.</p>
<pre><code class="lang-csharp">//
// GET: /Manage/Index
public async Task&lt;ActionResult&gt; Index(ManageMessageId? message)
{
    ViewBag.StatusMessage =
        message == ManageMessageId.ChangePasswordSuccess ? &quot;Your password has been changed.&quot;
        : message == ManageMessageId.SetPasswordSuccess ? &quot;Your password has been set.&quot;
        : message == ManageMessageId.SetTwoFactorSuccess ? &quot;Your two-factor authentication provider has been set.&quot;
        : message == ManageMessageId.Error ? &quot;An error has occurred.&quot;
        : message == ManageMessageId.AddPhoneSuccess ? &quot;Your phone number was added.&quot;
        : message == ManageMessageId.RemovePhoneSuccess ? &quot;Your phone number was removed.&quot;
        : message == ManageMessageId.UpdateBiographySuccess ? &quot;Your biography was updated.&quot;
        : &quot;&quot;;

    var userId = User.Identity.GetUserId();
    var model = new IndexViewModel
    {
        HasPassword = HasPassword(),
        PhoneNumber = await UserManager.GetPhoneNumberAsync(userId),
        TwoFactor = await UserManager.GetTwoFactorEnabledAsync(userId),
        Logins = await UserManager.GetLoginsAsync(userId),
        BrowserRemembered = await AuthenticationManager.TwoFactorBrowserRememberedAsync(userId),
        Biography = await UserManager.GetBiographyAsync(userId),
    };
    return View(model);
}
</code></pre>
<div class="exercise-end"></div>

<p>Phew! That was a huge update to the code base. Compile and cross your fingers ;-).</p>
<p>When you launch the app to test, login and navigate to the profile management page. You should see something similar to the image below. If you don&#39;t, that&#39;s ok. You can always grab the code from the <code>chapter6</code> branch of the Github repository.</p>
<p><img src="images/chapter5/manage-biography.gif" class="img-large" /></p>
<h4 id="summary">Summary</h4>
<p>In this chapter, you learned:</p>
<ul>
<li>It&#39;s easy to extend ASP.NET identity by adding a public property to the <code>ApplicationUser</code> class</li>
<li>The <code>ApplicationUserManager</code> class acts as a repository for application users</li>
</ul>
<p>In the next chapter, we&#39;ll continue to extend ASP.NET Identity by adding a profile picture to our app.</p>

			</div>
			<hr>
			<div class="chapter">
				<h2 id="adding-a-profile-picture-to-the-app">Adding a profile picture to the app</h2>
<p>In this chapter you will learn:</p>
<ul>
<li>How to extend ASP.NET Identity by adding an image to a user profile</li>
<li>How to upload files to Azure blob storage</li>
</ul>
<p>In the last chapter, you learned how to extend ASP.NET Identity by adding a biography to a user&#39;s profile. You also saw that by adding a public property to the <code>ApplicationUser</code> class, ASP.NET Identity managed the schema.</p>
<p>We&#39;ll continue extending ASP.NET Identity in this chapter by adding an image to the user profile management page.</p>
<h3 id="visualizing-what-you-re-building">Visualizing What You&#39;re Building</h3>
<p>Before we jump in, let&#39;s take a minute to visualize what you&#39;ll be building in this chapter.</p>
<p><img src="images/chapter6/upload-picture.gif" class="img-large" /></p>
<p>We&#39;ll be adding the <em>Profile Picture</em> field. Once added, you&#39;ll be able to see your uploaded picture on the main page and navigate to a second page to update it.</p>
<p>Let&#39;s get started! We&#39;ll begin by modifying ASP.NET Identity to include the new field, then move on to modifying the MVC code.</p>
<h3 id="extending-asp-net-identity">Extending ASP.NET Identity</h3>
<p>You&#39;ll recall that we previously updated the <code>ApplicationUser</code> and <code>ApplicationUserManager</code> classes to extend ASP.NET Identity. We&#39;ll be doing something similar for the profile picture. </p>
<h4 class="exercise-start">
    <b>Exercise</b>: Extending ASP.NET Identity with a Profile Picture
</h4>

<p>To extend ASP.NET Identity, add two things:</p>
<ol>
<li>public property to the <code>ApplicationUser</code> class</li>
<li>async accessor function for the property to the <code>ApplicationUserManager</code> class</li>
</ol>
<h4 id="updating-the-applicationuser-class">Updating the <code>ApplicationUser</code> class</h4>
<p>Add a public property to the <code>ApplicationUser</code> class, located in the the <em>IdentityModel.cs</em> file. You can find this file in the <em>Models</em> folder.</p>
<p>You&#39;ll remember this is the class that inherits from <code>IdentityUser</code>, the class ASP.NET Identity uses to represent a user. </p>
<pre><code class="lang-csharp">public string ProfilePicUrl { get; set; }
</code></pre>
<p>You may have noticed something interesting about the property you just added: it&#39;s a string, not an image. But why?</p>
<blockquote>
<p><strong>NOTE:</strong> We could add a binary property to store the actual image, but that would store the images as a column in the <em>AspNetUsers</em> table in Azure table storage. Table storage is great for semi-structured text data, but not so good for blob (binary large object) data, like an image. Instead, we&#39;ll be using a different type of Azure storage to store our images, called blob storage. We&#39;re not going to cover the details of blob storage right now, but it&#39;s important you understand why we&#39;re not adding a binary property to the <code>ApplicationUser</code> class.</p>
</blockquote>
<p>So, if we&#39;re not storing binary data in the <code>ApplicationUser</code> class, why are we storing a URL? You may recall from a previous chapter that data stored in an Azure storage account can be accessed via URL in the form of <em><a href="https://{storage-account-name}.{storage-type}.core.windows.net">https://{storage-account-name}.{storage-type}.core.windows.net</a></em>. </p>
<p>After uploading an image to blob storage, we&#39;ll save the image URL to our user profile.  </p>
<h4 id="updating-the-applicationusermanager-class">Updating the <code>ApplicationUserManager</code> class</h4>
<p>We also need to add an asynchronous accessor function to the <code>ApplicationUserManager</code> class (just like we did for the biography property). The method will take a <code>userId</code> and return the user&#39;s profile picture URL. You can find the <code>ApplicationUserManager</code> class in the <em>IdentityConfig.cs</em> file, located in the <em>App_Start</em> folder.</p>
<p>Add this code after the constructor.</p>
<pre><code class="lang-csharp">public async Task&lt;string&gt; GetProfilePicUrlAsync(string userId)
{
    var user = await this.Store.FindByIdAsync(userId);
    return (user != null) ? user.ProfilePicUrl : string.Empty;
}
</code></pre>
<p>This function uses the <code>Store</code> object, which is of type <code>IUserStore&lt;ApplicationUser&gt;</code>, which (simply put) is the object that manages storing and retrieving user data from our Azure table. </p>
<p>The <code>this.Store.FindByIdAsync(userId)</code> call gets a reference to our user. We then return the user&#39;s profile picture URL, or an empty string if the user isn&#39;t found.</p>
<div class="exercise-end"></div>

<p>That&#39;s it. Let&#39;s move on to updating our MVC app to support the profile picture property.</p>
<h3 id="updating-mvc-code-to-support-the-profile-picture-property">Updating MVC code to Support the Profile Picture Property</h3>
<p>Now that you&#39;ve added the property, let&#39;s update the MVC models, views, and controller actions to support the addition of the profile picture property.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Updating the MVC code to support the profile picture property
</h4>

<p>This exercise (just like the biography property exercise) is a bit longer than others, because we&#39;ll be updating a lot of files. At a high level, we&#39;ll be adding the profile picture property to our web app in several steps. </p>
<p>We&#39;ll start with the profile management page, which will show the profile picture:</p>
<ul>
<li><strong>Step 1:</strong> Update the <code>IndexViewModel</code> in <em>ManageViewModels.cs</em></li>
<li><strong>Step 2:</strong> Update the Manage\Index view </li>
</ul>
<p>Then we&#39;ll move on to a new page that uploads the profile picture:</p>
<ul>
<li><strong>Step 3:</strong> Update the <code>UpdateBiographyViewModel</code> class in <em>ManageViewModels.cs</em></li>
<li><strong>Step 4:</strong> Update the Update Biography view</li>
<li><strong>Step 5:</strong> Update the GET controller action for the Update Biography view to <em>ManageController.cs</em></li>
<li><strong>Step 6:</strong> Update the POST controller action for the Update Biography view to <em>ManageController.cs</em></li>
<li><strong>Step 7:</strong> Add application settings to <em>web.config</em> </li>
</ul>
<p>Finally, we&#39;ll return to the profile management page:</p>
<ul>
<li><strong>Step 8:</strong> Update the GET controller action for the Index view in <em>ManageController.cs</em> to populate the view with the updated profile picture URL</li>
</ul>
<p>There&#39;s a lot to do, so let&#39;s get moving!</p>
<h4 id="-step-1-update-the-indexviewmodel-in-manageviewmodels-cs-"><strong>Step 1:</strong> Update the <code>IndexViewModel</code> in <em>ManageViewModels.cs</em></h4>
<p>Start by updating the <code>IndexViewModel</code> class. Add a property for the profile picture URL.</p>
<pre><code class="lang-csharp">public class IndexViewModel
{
    public bool HasPassword { get; set; }
    public IList&lt;UserLoginInfo&gt; Logins { get; set; }
    public string PhoneNumber { get; set; }
    public bool TwoFactor { get; set; }
    public bool BrowserRemembered { get; set; }
    public string Biography { get; set; }
    public string ProfilePicUrl { get; set; }
}
</code></pre>
<blockquote>
<p>Adding this property will allow the index view to display the profile picture when it loads. We&#39;ll be setting the value of the URL later in this exercise when we update the index controller&#39;s GET action.</p>
</blockquote>
<h4 id="-step-2-update-the-manage-index-view"><strong>Step 2:</strong> Update the Manage\Index view</h4>
<p>Update <em>Index.cshtml</em> in the <em>Views\Manage</em> folder to display:</p>
<ul>
<li>Image with it&#39;s source set to the profile picture URL</li>
<li>An MVC HiddenFor element</li>
</ul>
<blockquote>
<p><strong>NOTE:</strong> You might be wondering what the MVC HiddenFor element is for. We&#39;ll be using this in a future chapter, so you can ignore it for now. </p>
</blockquote>
<p>Add this markup before the <code>&lt;dl class=&quot;dl-horizontal&quot;&gt;</code> element declaration:</p>
<pre><code class="lang-html">&lt;img id=&quot;profilePicture&quot; src=&quot;@Model.ProfilePicUrl&quot; alt=&quot;No profile picture specified.&quot; class=&quot;has-border&quot; style=&quot;width: 100%; max-width:300px;&quot; /&gt;
@Html.HiddenFor(x =&gt; x.ProfilePicUrl, new { id = &quot;profilePictureUrl&quot; })
</code></pre>
<p>When the page loads, the profile picture will be downloaded from the URL specified. </p>
<h4 id="-step-3-update-the-updatebiographyviewmodel-class-in-manageviewmodels-cs-"><strong>Step 3:</strong> Update the <code>UpdateBiographyViewModel</code> class in <em>ManageViewModels.cs</em></h4>
<p>In the last chapter, you created the <code>UpdateBiographyViewModel</code> class in the <em>ManageViewModels.cs</em> file. It was used to view and update a user&#39;s biography from the Update Biography view. </p>
<p>Update the class by adding several fields for the profile picture.</p>
<pre><code class="lang-csharp">public class UpdateBiographyViewModel
{
    [Display(Name = &quot;Biography&quot;)]
    public string Biography { get; set; }

    [Display(Name = &quot;Profile Picture&quot;)]
    [DataType(DataType.Upload)]
    public HttpPostedFileBase ProfilePicture { get; set; }

    public string ProfilePicUrl { get; set; }
}
</code></pre>
<p>You&#39;ll notice we added two properties: <code>ProfilePicture</code> and <code>ProfilePicUrl</code>:</p>
<ul>
<li><strong>ProfilePicture:</strong> stores the image binary, when uploaded</li>
<li><strong>ProfilePictureURL:</strong> displays the current profile picture to users </li>
</ul>
<p>When you add the <code>ProfilePicture</code> property, you&#39;ll need to add an additional reference to the top of the file because <code>HttpPosedFileBase</code> resides in the <code>System.Web</code> namespace.</p>
<p>Add the <code>System.Web</code> reference to the <em>ManageViewModels.cs</em> file.</p>
<pre><code class="lang-csharp">using System.Web;
</code></pre>
<h4 id="-step-4-update-the-update-biography-view"><strong>Step 4:</strong> Update the Update Biography view</h4>
<p>Update the view named <code>UpdateBiography.cshtml</code> in the <em>Views\Manage</em> folder. This view will use the previously created <code>UpdateBiographyViewModel</code> to show and update a user&#39;s profile picture.</p>
<p>Add an additional <code>&lt;div class=&quot;form-group&quot;&gt;...&lt;/div&gt;</code> element between the existing <code>&lt;div&gt;</code> elements. </p>
<pre><code class="lang-html">&lt;div class=&quot;form-group&quot;&gt;
    @Html.LabelFor(m =&gt; m.ProfilePicture, new { @class = &quot;col-md-2 control-label&quot; })
    &lt;div class=&quot;col-md-10&quot;&gt;
        &lt;img src=&quot;@Model.ProfilePicUrl&quot; alt=&quot;Profile picture not present or not approved.&quot; class=&quot;has-border&quot; style=&quot;width: 100%; max-width: 300px;&quot; /&gt;
        @Html.TextBoxFor(m =&gt; m.ProfilePicture, new { type = &quot;file&quot; })
        @Html.HiddenFor(m =&gt; m.ProfilePicUrl)
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h4 id="-step-5-update-the-get-controller-action-for-the-update-biography-view-in-managecontroller-cs-"><strong>Step 5:</strong> Update the GET controller action for the Update Biography view in <em>ManageController.cs</em></h4>
<p>Update the GET controller action in the <em>ManageController.cs</em> file to populate the profile picture URL property of the model.</p>
<pre><code class="lang-csharp">//
// Get: /Manage/UpdateBiography
public async Task&lt;ActionResult&gt; UpdateBiography()
{
    var userId = User.Identity.GetUserId();
    var updateBiographyViewModel = new UpdateBiographyViewModel()
    {
        Biography = await UserManager.GetBiographyAsync(userId),
        ProfilePicUrl = await UserManager.GetProfilePicUrlAsync(userId)
    };

    return View(updateBiographyViewModel);
}
</code></pre>
<h4 id="-step-6-update-the-post-controller-action-for-the-update-biography-view-in-managecontroller-cs-"><strong>Step 6:</strong> Update the POST controller action for the Update Biography view in <em>ManageController.cs</em></h4>
<p>Update the POST controller action in the Manage controller, using the <code>UpdateBiographySuccess</code> enum value just created.</p>
<pre><code class="lang-csharp">[HttpPost]
[ValidateAntiForgeryToken]
public async Task&lt;ActionResult&gt; UpdateBiography(UpdateBiographyViewModel model)
{
    if (!ModelState.IsValid)
    {
        return View(model);
    }
    var user = await UserManager.FindByIdAsync(User.Identity.GetUserId());
    if (user != null)
    {
        user.Biography = model.Biography;
        user.ProfilePicUrl = await UploadImageAsync(model.ProfilePicUrl, model.ProfilePicture) ?? user.ProfilePicUrl;
        await UserManager.UpdateAsync(user);
    }
    return RedirectToAction(&quot;Index&quot;, new { Message = ManageMessageId.UpdateBiographySuccess });
}
</code></pre>
<p>We&#39;ve added a function call to populate the profile picture URL: <code>user.ProfilePicUrl = await UploadImageAsync(model.ProfilePicUrl, model.ProfilePicture) ?? user.ProfilePicUrl;</code>, but it may be a bit confusing, so let&#39;s break it down.</p>
<p>First, we call a function that uploads the profile picture to Azure blob storage: <code>UploadImageAsync(model.ProfilePicUrl, model.ProfilePicture)</code>. If the upload is successful, it returns the URL of the uploaded image. Otherwise, it returns <code>null</code>. </p>
<p>If that function returns <code>null</code>, the existing profile picture url is kept.</p>
<blockquote>
<p><strong>NOTE:</strong> You may not recognize the <code>??</code> syntax, as it&#39;s a feature of C# called the null-coalescing operator. It returns the left-hand operand if the operand is not null; otherwise it returns the right hand operand. For more information on this operator, check out the official <a href="https://msdn.microsoft.com/en-us/library/ms173224.aspx">documentation</a>.</p>
</blockquote>
<p>Add the <code>UploadImageAsync</code> function below the POST controller action.</p>
<pre><code class="lang-csharp">public async Task&lt;string&gt; UploadImageAsync(string currentBlobUrl, HttpPostedFileBase imageToUpload)
{
    string imageFullPath = null;
    if (imageToUpload == null || imageToUpload.ContentLength == 0)
    {
        return null;
    }
    try
    {
        // connect to our storage account
        var cloudStorageAccount = CloudStorageAccount.Parse($&quot;DefaultEndpointsProtocol=https;AccountName={ConfigurationManager.AppSettings[&quot;StorageAccountName&quot;]};AccountKey={ConfigurationManager.AppSettings[&quot;StorageAccountKey&quot;]};&quot;);
        var cloudBlobClient = cloudStorageAccount.CreateCloudBlobClient();
        var cloudBlobContainer = cloudBlobClient.GetContainerReference(ConfigurationManager.AppSettings[&quot;ProfilePicBlobContainer&quot;]);

        // create the blob storage container, if needed
        if (await cloudBlobContainer.CreateIfNotExistsAsync())
        {
            await cloudBlobContainer.SetPermissionsAsync(
                new BlobContainerPermissions
                {
                    PublicAccess = BlobContainerPublicAccessType.Blob
                }
            );
        }

        var imageName = $&quot;{Guid.NewGuid()}{Path.GetExtension(imageToUpload.FileName)}&quot;;

        // upload image blob
        var cloudBlockBlob = cloudBlobContainer.GetBlockBlobReference(imageName);
        cloudBlockBlob.Properties.ContentType = imageToUpload.ContentType;
        await cloudBlockBlob.UploadFromStreamAsync(imageToUpload.InputStream);

        // get URL of uploaded image blob
        imageFullPath = cloudBlockBlob.Uri.ToString();
    }
    catch (Exception ex)
    {
        // in reality, you should handle this...
    }
    return imageFullPath;
}
</code></pre>
<p>There are 4 things happening in the upload function:</p>
<ul>
<li><strong>Connect to Storage Account:</strong> Using the <code>CloudStorageAccount</code> class, parse the storage account connection string, create a blob client, and a reference to the container (or folder) we&#39;d like to access. The blob client works like a web service proxy that can interact with Azure blob storage to get a reference to the blob folders (a.k.a. containers) in the account. </li>
<li><strong>Create the blob container:</strong> It&#39;s important to know that the reference to the blob container doesn&#39;t mean the cloud container exists. Whenever you access a container, you should first ensure that it exists. If not, create it. This may seem extra, but always checking for the container helps you to write more defensive code that ensures any implicit assumptions (like the existence of the container) are valid.</li>
<li><strong>Upload image blob:</strong> With the container reference, we get a reference to a blob block (a.k.a. file) that will contain our image. After setting the content type of the blob block, the image bits are uploaded.</li>
<li><strong>Get URL of the uploaded image blob:</strong> When the image is uploaded, we get the URL of it via the <code>Uri</code> property. </li>
</ul>
<blockquote>
<p><strong>NOTE:</strong> Throughout the code we&#39;ve written to access cloud resources, you&#39;ll notice a clear asynchronous programming pattern. When you&#39;re interacting with the cloud, you should always perform action in an asynchronous manner because you never know how long an action will take. In the event an action takes longer than expected, executing the command asynchronously won&#39;t prevent other code from executing.</p>
</blockquote>
<p>The last step is to add several references to the top of the <em>ManageController.cs</em> file:</p>
<pre><code class="lang-csharp">using Microsoft.WindowsAzure.Storage;
using System.Configuration;
using Microsoft.WindowsAzure.Storage.Blob;
using System.IO;
</code></pre>
<h4 id="-step-7-add-application-settings-to-web-config-"><strong>Step 7:</strong> Add application settings to <em>web.config</em></h4>
<p>Various functions and code we&#39;ve added reference application settings via the <code>ConfigurationManager</code> class. Add the following keys to the <code>&lt;appSettings&gt;...&lt;/appSettings&gt;</code> element of the <em>web.config</em> file.</p>
<pre><code class="lang-xml">    &lt;add key=&quot;StorageAccountName&quot; value=&quot;STORAGE_ACCOUNT_NAME&quot; /&gt;
    &lt;add key=&quot;StorageAccountKey&quot; value=&quot;STORAGE_ACCOUNT_KEY&quot; /&gt;
    &lt;add key=&quot;ProfilePicBlobContainer&quot; value=&quot;profile-pics&quot; /&gt;
</code></pre>
<p>The <code>StorageAccountName</code> and <code>StorageAccountKey</code> keys are the same account name and key you added to the storage account connection string earlier. If you&#39;re unsure of these values, look at the El Camino configuration section.</p>
<p>The <code>ProfilePicBlobContainer</code> key is a blob container name that will hold our uploaded images. Don&#39;t change these. In this chapter, the image upload function uses the key to upload profile pictures to the blob container named <em>profile-pics</em>. </p>
<h4 id="-step-8-update-the-get-controller-action-for-the-index-view-in-managecontroller-cs-"><strong>Step 8:</strong> Update the GET controller action for the Index view in <em>ManageController.cs</em></h4>
<p>The final step is to update the GET controller action of the Manage\Index view. The entire function is included below. </p>
<pre><code class="lang-csharp">//
// GET: /Manage/Index
public async Task&lt;ActionResult&gt; Index(ManageMessageId? message)
{
    ViewBag.StatusMessage =
        message == ManageMessageId.ChangePasswordSuccess ? &quot;Your password has been changed.&quot;
        : message == ManageMessageId.SetPasswordSuccess ? &quot;Your password has been set.&quot;
        : message == ManageMessageId.SetTwoFactorSuccess ? &quot;Your two-factor authentication provider has been set.&quot;
        : message == ManageMessageId.Error ? &quot;An error has occurred.&quot;
        : message == ManageMessageId.AddPhoneSuccess ? &quot;Your phone number was added.&quot;
        : message == ManageMessageId.RemovePhoneSuccess ? &quot;Your phone number was removed.&quot;
        : message == ManageMessageId.UpdateBiographySuccess ? &quot;Your biography was updated.&quot;
        : &quot;&quot;;

    var userId = User.Identity.GetUserId();
    var model = new IndexViewModel
    {
        HasPassword = HasPassword(),
        PhoneNumber = await UserManager.GetPhoneNumberAsync(userId),
        TwoFactor = await UserManager.GetTwoFactorEnabledAsync(userId),
        Logins = await UserManager.GetLoginsAsync(userId),
        BrowserRemembered = await AuthenticationManager.TwoFactorBrowserRememberedAsync(userId),
        Biography = await UserManager.GetBiographyAsync(userId),
        ProfilePicUrl = await UserManager.GetProfilePicUrlAsync(userId)
    };
    return View(model);
}
</code></pre>
<div class="exercise-end"></div>

<p>Another <em>huge</em> update. Compile it again.</p>
<p>When you launch the app to test, login and navigate to the profile management page. You should see something similar to the image below. If you don&#39;t, that&#39;s ok. You can always grab the code from the <code>chapter7</code> branch of the Github repository.</p>
<p><img src="images/chapter6/upload-picture.gif" class="img-large" /></p>
<p>Before we&#39;re finished, let&#39;s take a look at Storage Explorer to see our uploaded profile picture.</p>
<p>Click <em>Refresh All</em>, browse to your Azure storage account, and open the <em>Blob Containers</em> element. Inside, you&#39;ll see the <em>profile-pics</em> container. Selecting the container will show the uploaded profile pictures.</p>
<p><img src="images/chapter6/profile-pics-uploaded.gif" class="img-large" /></p>
<h4 id="summary">Summary</h4>
<p>In this chapter, you learned:</p>
<ul>
<li>Why you shouldn&#39;t store blobs in Azure table storage, and that blob storage is a much better choice</li>
<li>When interacting with the cloud, you should use asynchronous method calls</li>
<li>When you reference blob containers, always check if they exist before using them</li>
</ul>
<p>In the next chapter, we&#39;ll continue to explore blob storage by uploading profile pictures to a holding zone where images will need to be approved prior to being accepted as a profile picture.</p>

			</div>
			<hr>
			<div class="chapter">
				<h2 id="building-a-staging-blob-container-profile-pictures">Building a Staging Blob Container Profile Pictures</h2>
<p>This is a short chapter, but sets the stage for something big. Imagine the web app we&#39;ve been building was going to be used in a production capacity. Do you really want to give users the ability to upload <em>any</em> image for their profile picture? Some images just aren&#39;t suitable for a work environment. </p>
<p>Wouldn&#39;t it be nice to add a step into the profile image upload process where images were screened? But, who&#39;s going to do the screening? Do you really have time to screen <em>every</em> images uploaded. Maybe it makes sense for a small site, but what happens when there&#39;s thousands of users? </p>
<p>For me, there&#39;s no chance that I would introduce a manual screen step. Instead, I&#39;d look for every opportunity to automate this process so I can spend the time to write code once, and use it every time someone changes their profile picture. </p>
<p>Over the next several chapters, we&#39;ll be building an automated image screening process using <a href="https://www.microsoft.com/cognitive-services/en-us/computer-vision-api">Microsoft&#39;s Cognitive Services Computer Vision API</a>. We&#39;ll combine various Azure services: blob storage containers, an Azure function listening for changes to a blob container, and REST service calls to the computer vision API. The computer vision API will process each uploaded image, indicating whether it is work appropriate. Images that are acceptable will be moved to the profile picture blob container. Invalid images will be moved to a separate container.  </p>
<p>In this chapter, we&#39;ll start building the automated process by modifying our web app to place the uploaded images in a staging blob container. Let&#39;s get started.</p>
<h3 id="creating-a-profile-picture-staging-blob-container">Creating a Profile Picture Staging Blob Container</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Extending ASP.NET Identity with a Profile Picture
</h4>

<p>This is a fairly short exercise, where you&#39;ll do 2 things to create a staging blob container for profile pictures:</p>
<ul>
<li><strong>Step 1:</strong> Create a web.config app setting for the upload/staging blob container name </li>
<li><strong>Step 2:</strong> Update the upload image function to upload images to the staging blob container</li>
</ul>
<h4 id="-step-1-create-a-web-config-app-setting-for-the-upload-staging-blob-container-name"><strong>Step 1:</strong> Create a web.config app setting for the upload/staging blob container name</h4>
<p>Add a new app setting to the <em>web.config</em> file named <code>ProfilePicUploadBlobContainer</code>.</p>
<pre><code class="lang-xml">&lt;add key=&quot;ProfilePicUploadBlobContainer&quot; value=&quot;uploaded&quot; /&gt;
</code></pre>
<h4 id="-step-2-update-the-upload-image-function-to-upload-images-to-the-staging-blob-container"><strong>Step 2:</strong> Update the upload image function to upload images to the staging blob container</h4>
<p>Update the <code>UploadImageAsync()</code> function to change the blob container images are uploaded to. You can find this function in <em>ManageController.cs</em>.</p>
<pre><code class="lang-csharp">public async Task&lt;string&gt; UploadImageAsync(string currentBlobUrl, HttpPostedFileBase imageToUpload)
{
    string imageFullPath = null;
    if (imageToUpload == null || imageToUpload.ContentLength == 0)
    {
        return null;
    }
    try
    {
        // connect to our storage account
        var cloudStorageAccount = CloudStorageAccount.Parse($&quot;DefaultEndpointsProtocol=https;AccountName={ConfigurationManager.AppSettings[&quot;StorageAccountName&quot;]};AccountKey={ConfigurationManager.AppSettings[&quot;StorageAccountKey&quot;]};&quot;);
        var cloudBlobClient = cloudStorageAccount.CreateCloudBlobClient();
        var cloudBlobContainer = cloudBlobClient.GetContainerReference(ConfigurationManager.AppSettings[&quot;ProfilePicUploadBlobContainer&quot;]);

        // create the blob storage container, if needed
        if (await cloudBlobContainer.CreateIfNotExistsAsync())
        {
            await cloudBlobContainer.SetPermissionsAsync(
                new BlobContainerPermissions
                {
                    PublicAccess = BlobContainerPublicAccessType.Blob
                }
            );
        }

        var imageName = $&quot;{Guid.NewGuid()}{Path.GetExtension(imageToUpload.FileName)}&quot;;

        // upload image blob
        var cloudBlockBlob = cloudBlobContainer.GetBlockBlobReference(imageName);
        cloudBlockBlob.Properties.ContentType = imageToUpload.ContentType;
        await cloudBlockBlob.UploadFromStreamAsync(imageToUpload.InputStream);

        // get URL of uploaded image blob - replacing the staging/upload container name 
        // with the valid blob container name
        imageFullPath = cloudBlockBlob.Uri.ToString().Replace(ConfigurationManager.AppSettings[&quot;ProfilePicUploadBlobContainer&quot;], ConfigurationManager.AppSettings[&quot;ProfilePicBlobContainer&quot;]);
    }
    catch (Exception ex)
    {
        // in reality, you should handle this...
    }
    return imageFullPath;
}
</code></pre>
<p>The changes made are straight-forward, but we&#39;d like to call attention to the <code>imageFullPath</code> variable and it&#39;s value: </p>
<pre><code class="lang-csharp">imageFullPath = 
    cloudBlockBlob.Uri.ToString()
        .Replace(
            ConfigurationManager.AppSettings[&quot;ProfilePicUploadBlobContainer&quot;], 
            ConfigurationManager.AppSettings[&quot;ProfilePicBlobContainer&quot;]);
</code></pre>
<p>From the previous chapter, you&#39;ll recall that <code>cloudBlockBlob</code> is a reference to the uploaded blob image. After this change, the blob container we&#39;ll be uploading it to the staging/upload container named <em>uploaded</em> (stored in the <code>ProfilePicUploadBlobContainer</code> app setting). This staging/upload container should not be returned to the app, because images in this container have not been processed with the computer vision API. </p>
<p>When images get processed, valid profile pictures will be placed in the <em>profile-pics</em> container (stored in the <code>ProfilePicBlobContainer</code> app setting). As a result, the URL returned from the upload function returns the URL of the valid image. </p>
<p>Let&#39;s test it out! Compile and run the web app. When you upload a new image, you should expect the image to be placed into the <em>uploaded</em> blob container, and the profile management page to not display an image (because we haven&#39;t created the Azure function to validate the pictures with the computer vision API).</p>
<p><img src="images/chapter7/profile-pics-uploaded.gif" class="img-large" /></p>
<p>Use Storage Explorer to check out the blob containers. You should see the <em>profile-pics</em> and <em>uploaded</em> containers. The <em>profile-pics</em> container will have the original profile picture inside, and the <em>uploaded</em> container will have the new profile picture.</p>
<p><img src="images/chapter7/storage-explorer.gif" class="img-large" /></p>
<div class="exercise-end"></div>

<p>That concludes this chapter. We said it would be a short one. </p>
<h4 id="summary">Summary</h4>
<p>In this chapter, you:</p>
<ul>
<li>Learned about the automated profile picture analysis process we&#39;ll be implementing</li>
<li>Updated the web app to upload images to a different blob container that will be used as an upload/staging area</li>
<li>Verified the creation of the upload/staging blob container and verified images were added to the correct blob container</li>
</ul>
<p>In the next chapter, we&#39;ll finish building the automated profile picture analysis process.</p>

			</div>
			<hr>
			<div class="chapter">
				<h2 id="processing-profile-pictures-with-azure-functions">Processing Profile Pictures with Azure Functions</h2>
<blockquote>
<p><em>NOTE:</em> This chapter was adapted from Microsoft&#39;s Technical Community Content Github repository. To find out more and see the original content, visit <a href="https://github.com/Microsoft/TechnicalCommunityContent/tree/master/Cloud%20Computing/Azure%20Functions/Session%202%20-%20Hands%20On">Github</a>.</p>
</blockquote>
<p>Functions have been the basic building blocks of software since the first lines of code were written and the need for code organization and reuse became a necessity. Azure Functions expand on these concepts by allowing developers to create &quot;serverless&quot;, event-driven functions that run in the cloud and can be shared across a wide variety of services and systems, uniformly managed, and easily scaled based on demand. In addition, Azure Functions can be written in a variety of languages, including C#, JavaScript, Python, Bash, and PowerShell, and they&#39;re perfect for building apps and nanoservices that employ a compute-on-demand model.</p>
<p>In this chapter, you&#39;ll create an Azure Function that monitors a blob container in Azure Storage for new images, and then performs automated analysis of the images using the Microsoft Cognitive Services <a href="https://www.microsoft.com/cognitive-services/en-us/computer-vision-api">Computer Vision API</a>. Specifically, The Azure Function will analyze each image that is uploaded to the container for inappropriate content and create a copy of the image in another container. Images that contain inappropriate content will be copied to one container (the <em>rejected</em> container), and images that are acceptable copied to another (the <em>profile-pics</em> container). In addition, the analysis data returned by the Computer Vision API will be stored in blob metadata.</p>
<h3 id="creating-an-azure-function-app">Creating an Azure Function App</h3>
<p>The first step in writing an Azure Function is to create an Azure Function App. In this exercise, you&#39;ll create an Azure Function App using the Azure Portal. Then you&#39;ll add the <em>rejected</em> blob container to the storage account you&#39;ve used throughout this workshop. The <em>rejected</em> container will contain images classified as inappropriate content. </p>
<p>If you&#39;re wondering about the other two containers mentioned above, don&#39;t worry. You&#39;ve already created them as part of previous chapters. We&#39;ll continue to use them in this chapter. </p>
<h4 class="exercise-start">
    <b>Exercise</b>: Create an Azure Function App
</h4>

<p>Open the <a href="https://portal.azure.com">Azure Portal</a> in your browser. If asked to log in, do so using your Microsoft account. </p>
<p>Click <em>+ New</em>, followed by <em>Compute</em> and <em>Function App</em>.</p>
<p><img src="images/chapter8/new-function-app.png" class="img-medium" /></p>
<p>You&#39;ll be presented with a Function App creation blade.</p>
<p><img src="images/chapter8/create-function-app.png" class="img-small" /></p>
<p>Enter an app name that is unique within Azure. Under <em>Resource Group</em>, select <em>Use existing</em> and select the resource group your created earlier. Choose <em>App Service plan/Location</em> for the <em>Hosting Plan</em>, and select the same storage account you created earlier. Make sure the <em>Pin to dashboard</em> is checked.</p>
<p>Click <em>Create</em> to create a new Function App. The function app will start it&#39;s deployment process. </p>
<p><img src="images/chapter8/deploying-function-app.png" class="img-small" /></p>
<p>While you&#39;re waiting for the function app to be created, open the resource group created earlier and locate your storage account. Open the storage account in the portal. </p>
<p>Click <em>Blobs</em> to view the contents of blob storage.</p>
<p><img src="images/chapter8/open-blob-storage.png" alt="Opening blob storage"></p>
<p>You should see several containers inside of your blob storage: <em>profile-pics</em>, <em>uploaded</em>, and <em>azure-webjobs-hosts</em>. You previously created <em>profile-pics</em> and <em>uploaded</em> during previous chapters. The <em>azure-webjobs-hosts</em> container is created by the function app provisioning process, so you may not see it if the function app you just created hasn&#39;t been fully provisioned.</p>
<p>Click <em>+ Container</em> to add a container.</p>
<p><img src="images/chapter8/add-container.png" class="img-large" /></p>
<p>Type <em>rejected</em> into the <em>Name</em> box. Select <em>Blob</em> for the <em>Access type</em>. Then click the <em>Create</em> button to create the container.</p>
<p><img src="images/chapter8/name-container.png" alt="Naming the container"></p>
<p>Repeat the previous steps to add containers named <em>profile-pics</em> and <em>uploaded</em> if they don&#39;t exist.</p>
<div class="exercise-end"></div>

<p>Great work! You&#39;ve created the function app and have the three containers needed to store uploaded, rejected, and valid profile pictures. The next step is to add an Azure Function.</p>
<h3 id="creating-an-azure-function">Creating an Azure Function</h3>
<p>Once you have created an Azure Function App, you can add Azure Functions to it. In this exercise, you&#39;ll add a function to the Function App you created in the previous exercise and write C# code that uses the <a href="https://www.microsoft.com/cognitive-services/en-us/computer-vision-api">Computer Vision API</a> to analyze images added to the &quot;uploaded&quot; container for inappropriate content.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Create an Azure Function
</h4>

<p>Return to the workshop dashboard and click the Azure Function App that you created and pinned in the previous exercise. </p>
<p><img src="images/chapter8/open-function-app.png" class="img-small" /></p>
<p>Click the <em>+</em> symbol next to <em>Functions</em>, as shown in the image below.</p>
<p><img src="images/chapter8/create-azure-function.gif" class="img-large" /></p>
<p>Scroll past the <em>Get started quickly...</em> heading and click <em>Custom function</em> under the <em>Get started on your own</em> heading. Click <em>BlobTrigger-CSharp</em>. </p>
<p>Enter <em>BlobImageAnalysis</em> for the function name and &quot;uploaded/{name}.{ext}&quot; into the <em>Path</em> box. (The latter applies the blob storage trigger to the &quot;uploaded&quot; container that you created earlier in this workshop.) <em>{name}</em> and <em>{ext}</em> refer to function app parameters that will be passed in by the Azure function app API automatically. For example, when a profile picture is uploaded with the name mypicture.jpeg, it will be parsed into two variables: <em>name</em> (with a value of <em>mypicture</em>) and <em>ext</em> (with a value of <em>jpeg</em>). </p>
<p>Click the <em>Create</em> button to create the Azure Function.</p>
<p>When the Azure Function is created, a code editor window will appear. </p>
<p><img src="images/chapter8/code-editor.png" class="img-large" /></p>
<p>Replace the code shown in the code editor with the following statements:</p>
<pre><code class="lang-csharp">using Microsoft.WindowsAzure.Storage.Blob;
using Microsoft.WindowsAzure.Storage;
using System.Net.Http.Headers;
using System.Configuration;

public async static Task Run(Stream myBlob, string name, string ext, TraceWriter log)
{       
    log.Info($&quot;Analyzing uploaded image {name} for appropriate content...&quot;);

    var array = await ToByteArrayAsync(myBlob);
    var result = await AnalyzeImageAsync(array, log);

    log.Info(&quot;Is Adult: &quot; + result.adult.isAdultContent.ToString());
    log.Info(&quot;Adult Score: &quot; + result.adult.adultScore.ToString());
    log.Info(&quot;Is Racy: &quot; + result.adult.isRacyContent.ToString());
    log.Info(&quot;Racy Score: &quot; + result.adult.racyScore.ToString());

    // Reset stream location
    myBlob.Seek(0, SeekOrigin.Begin);
    if (result.adult.isAdultContent || result.adult.isRacyContent)
    {
        // profile picture is NOT acceptable - copy blob to the &quot;rejected&quot; container
        StoreBlobWithMetadata(myBlob, &quot;rejected&quot;, name, ext, result, log);
    }
    else
    {
        // profile picture is acceptable - copy blob to the &quot;profile-pics&quot; container
        StoreBlobWithMetadata(myBlob, &quot;profile-pics&quot;, name, ext, result, log);
    }
}

private async static Task&lt;ImageAnalysisInfo&gt; AnalyzeImageAsync(byte[] bytes, TraceWriter log)
{
    HttpClient client = new HttpClient();

    var key = ConfigurationManager.AppSettings[&quot;SubscriptionKey&quot;].ToString();
    client.DefaultRequestHeaders.Add(&quot;Ocp-Apim-Subscription-Key&quot;, key);

    HttpContent payload = new ByteArrayContent(bytes);
    payload.Headers.ContentType = new MediaTypeWithQualityHeaderValue(&quot;application/octet-stream&quot;);

    var results = await client.PostAsync(&quot;https://westus.api.cognitive.microsoft.com/vision/v1.0/analyze?visualFeatures=Adult&quot;, payload);
    var result = await results.Content.ReadAsAsync&lt;ImageAnalysisInfo&gt;();
    return result;
}

// Writes a blob to a specified container and stores metadata with it
private static void StoreBlobWithMetadata(Stream image, string containerName, string blobName, string ext, ImageAnalysisInfo info, TraceWriter log)
{
    log.Info($&quot;Writing blob and metadata to {containerName} container...&quot;);

    var connection = ConfigurationManager.AppSettings[&quot;AzureWebJobsStorage&quot;].ToString();
    var account = CloudStorageAccount.Parse(connection);
    var client = account.CreateCloudBlobClient();
    var container = client.GetContainerReference(containerName);

    try
    {
        var blob = container.GetBlockBlobReference($&quot;{blobName}.{ext}&quot;);

        if (blob != null) 
        {
            // Upload the blob
            blob.UploadFromStream(image);

            // Set the content type of the image
            blob.Properties.ContentType = &quot;image/&quot; + ext;
            blob.SetProperties();

            // Get the blob attributes
            blob.FetchAttributes();

            // Write the blob metadata
            blob.Metadata[&quot;isAdultContent&quot;] = info.adult.isAdultContent.ToString(); 
            blob.Metadata[&quot;adultScore&quot;] = info.adult.adultScore.ToString(&quot;P0&quot;).Replace(&quot; &quot;,&quot;&quot;); 
            blob.Metadata[&quot;isRacyContent&quot;] = info.adult.isRacyContent.ToString(); 
            blob.Metadata[&quot;racyScore&quot;] = info.adult.racyScore.ToString(&quot;P0&quot;).Replace(&quot; &quot;,&quot;&quot;); 

            // Save the blob metadata
            blob.SetMetadata();
        }
    }
    catch (Exception ex)
    {
        log.Info(ex.Message);
    }
}

// Converts a stream to a byte array 
private async static Task&lt;byte[]&gt; ToByteArrayAsync(Stream stream)
{
    Int32 length = stream.Length &gt; Int32.MaxValue ? Int32.MaxValue : Convert.ToInt32(stream.Length);
    byte[] buffer = new Byte[length];
    await stream.ReadAsync(buffer, 0, length);
    return buffer;
}

public class ImageAnalysisInfo
{
    public Adult adult { get; set; }
    public string requestId { get; set; }
}

public class Adult
{
    public bool isAdultContent { get; set; }
    public bool isRacyContent { get; set; }
    public float adultScore { get; set; }
    public float racyScore { get; set; }
}
</code></pre>
<p><em>Run</em> is the method called each time the function is executed. The <em>Run</em> method uses a helper method named <em>AnalyzeImageAsync</em> to pass each blob added to the &quot;uploaded&quot; container to the Computer Vision API for analysis. Then it calls a helper method named <em>StoreBlobWithMetadata</em> to create a copy of the blob in either the &quot;profile-pics&quot; container or the &quot;rejected&quot; container, depending on the scores returned by <em>AnalyzeImageAsync</em>. </p>
<p>Click the <em>Save</em> button at the top of the code editor to save your changes. Then click <em>View Files</em>.</p>
<p><img src="images/chapter8/save-run-file.png" class="img-medium" /></p>
<p>Click <em>+ Add</em> to add a new file, and name the file <em>project.json</em>.</p>
<p><img src="images/chapter8/add-project-file.png" alt="image">  </p>
<p>Add the following statements to <em>project.json</em>:</p>
<pre><code class="lang-json">{
    &quot;frameworks&quot;: {
        &quot;net46&quot;: {
            &quot;dependencies&quot;: {
                &quot;WindowsAzure.Storage&quot;: &quot;8.1.1&quot;
            }
        }
    }
}
</code></pre>
<p>Click the <em>Save</em> button to save your changes. Then click <em>run.csx</em> to go back to that file in the code editor.</p>
<p><img src="images/chapter8/save-project-file.png" class="img-large" /></p>
<div class="exercise-end"></div>

<p>An Azure Function written in C# has been created, complete with a JSON project file containing information regarding project dependencies. The next step is to add an application setting that Azure Function relies on.</p>
<h3 id="adding-a-subscription-key-to-application-settings">Adding a Subscription Key to Application Settings</h3>
<p>The Azure Function you created in the previous exercise loads a subscription key for the Microsoft Cognitive Services Computer Vision API from application settings. This key is required in order for your code to call the Computer Vision API, and is transmitted in an HTTP header in each call. In this exercise, you will add an application setting containing the subscription key to the Function App.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add a Subscription Key to Application Settings
</h4>

<p>Open a new browser window and navigate to <a href="https://www.microsoft.com/cognitive-services/en-us/subscriptions">https://www.microsoft.com/cognitive-services/en-us/subscriptions</a>. If you haven&#39;t signed up for the Computer Vision API, do so now. (Signing up is free.) Then click <em>Copy</em> under <em>Key 1</em> in your Computer Vision subscription to copy the subscription key to the clipboard.</p>
<p><img src="images/chapter8/computer-vision-key.png" class="img-large" /></p>
<p>Return to your Function App in the Azure Portal and click on the function app name on the left (as shown in the image below).</p>
<p><img src="images/chapter8/goto-app-settings.gif" class="img-large" /></p>
<p>On the right, select the <em>Platform features</em> tab at top. Under <em>General Settings</em>, click <em>Application settings</em>. </p>
<p>Scroll down until you find the <em>App settings</em> section. Add a new app setting named <em>SubscriptionKey</em>, and paste the Cognitive Services API subscription key that is on the clipboard into the <em>Value</em> box. Then click <em>Save</em> at the top of the blade.</p>
<p><img src="images/chapter8/add-key.png" class="img-medium" /></p>
<p>The app settings are now configured for your Azure Function. </p>
<div class="exercise-end"></div>

<h3 id="testing-the-azure-function">Testing the Azure Function</h3>
<p>Your function is configured to listen for changes to the blob container named &quot;uploaded&quot; that you created earlier in this workshop. Each time an image appears in the container, the function executes and passes the image to the Computer Vision API for analysis. To test the function, you simply upload images to the container. In this exercise, you will use the Azure Portal to upload images to the &quot;uploaded&quot; container and verify that copies of the images are placed in the &quot;accepted&quot; and &quot;rejected&quot; containers.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Uploading an Image to Blob Storage
</h4>

<p>In the Azure Portal, go to the resource group created for your Function App. Then click the storage account that was created for it.</p>
<p>Click <em>Blobs</em> to view the contents of blob storage.</p>
<p><img src="images/chapter8/open-blob-storage.png" class="img-large" /></p>
<p>Click <em>uploaded</em> to open the &quot;uploaded&quot; container.</p>
<p><img src="images/chapter8/open-uploaded-container.png" class="img-large" /></p>
<p>Click <em>Upload</em>.</p>
<p><img src="images/chapter8/upload-images-1.png" class="img-large" /></p>
<p>Click the button with the folder icon to the right of the <em>Files</em> box. Select one or more image files. Then click the <em>Upload</em> button to upload the files to the &quot;uploaded&quot; container.</p>
<blockquote>
<p><strong>WARNING:</strong> Due to the nature of this exercise, your Azure Function can detect adult and racy images. Please, <strong>DO NOT</strong> upload inappropriate images during the lab. Be respectful of those around you. </p>
</blockquote>
<p><img src="images/chapter8/upload-images-2.png" alt="Uploading images to the &quot;uploaded&quot; container"></p>
<p>Return to the blade for the &quot;uploaded&quot; container and verify that the images you uploaded were uploaded. eight images were uploaded.</p>
<blockquote>
<p><strong>NOTE:</strong> These screenshots may be slightly different due to the number and names of images you uploaded.</p>
</blockquote>
<p><img src="images/chapter8/uploaded-images.png" class="img-medium" /></p>
<p>Close the blade for the &quot;uploaded&quot; container and open the &quot;profile-pics&quot; container.</p>
<p><img src="images/chapter8/open-accepted-container.png" class="img-large" /></p>
<p>Verify that the &quot;profile-pics&quot; container holds the images you uploaded. <em>These are the images that were classified as appropriate images by the Computer Vision API</em>.</p>
<blockquote>
<p>It may take a minute or more for all of the images to appear in the container. If necessary, click <em>Refresh</em> every few seconds until you see all the images you expect.</p>
</blockquote>
<p><img src="images/chapter8/accepted-images.png" class="img-large" /></p>
<p>Close the blade for the &quot;profile-pics&quot; container and open the blade for the &quot;rejected&quot; container.</p>
<p><img src="images/chapter8/open-rejected-container.png" class="img-large" /></p>
<p>Verify that the <em>rejected</em> container holds the number of images you would expect to be rejected. <em>These images were classified as inappropriate by the Computer Vision API</em>.</p>
<p>The presence of all images in the <em>profile-pics</em> and <em>rejected</em> containers is proof that your Azure Function executed each time an image was uploaded to the &quot;uploaded&quot; container. If you would like, return to the BlobImageAnalysis function in the portal and click <em>Monitor</em>. You will see a log detailing each time the function executed.</p>
<div class="exercise-end"></div>

<h3 id="viewing-blob-metadata">Viewing Blob Metadata</h3>
<p>What if you would like to view the scores for adult content and raciness returned by the Computer Vision API for each image uploaded to the &quot;uploaded&quot; container? The scores are stored in blob metadata for the images in the &quot;profile-pics&quot; and &quot;rejected&quot; containers, but blob metadata can&#39;t be viewed through the Azure Portal.</p>
<p>In this exercise, you will use the cross-platform <a href="http://storageexplorer.com">Microsoft Azure Storage Explorer</a> to view blob metadata and see how the Computer Vision API scored the images you uploaded.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: View Blob Metadata with Storage Explorer
</h4>

<p>Start Storage Explorer. Find your storage account you&#39;ve been working with and expand the list of blob containers underneath it. Then click the container named <em>profile-pics</em>.</p>
<p>Right-click an image in the &quot;profile-pics&quot; container and select <em>Properties</em> from the context menu.</p>
<p>Inspect the blob&#39;s metadata. <em>IsAdultContent</em> and <em>isRacyContent</em> are Boolean values that indicate whether the Computer Vision API detected adult or racy content in the image. <em>adultScore</em> and <em>racyScore</em> are the computed probabilities.</p>
<p><img src="images/chapter8/profile-pic-metadata.gif" class="img-large" /></p>
<p>You can probably imagine how this might be used in the real world. Suppose you were building a photo-sharing site and wanted to prevent adult images from being stored. You could easily write an Azure Function that inspects each image that is uploaded and deletes it from storage if it contains adult content.</p>
<div class="exercise-end"></div>

<h4 id="summary">Summary</h4>
<p>In this chapter you learned how to:</p>
<ul>
<li>Create an Azure Function App</li>
<li>Write an Azure Function that uses a blob trigger</li>
<li>Add application settings to an Azure Function App</li>
<li>Use Microsoft Cognitive Services to analyze images and store the results in blob metadata</li>
</ul>
<p>This is just one example of how you can leverage Azure Functions to automate repetitive tasks. Experiment with other Azure Function templates to learn more about Azure Functions and to identify additional ways in which they can aid your research or business.</p>
<p>In the next chapter, we&#39;ll take the web app to the next level by adding in a SignalR hub, and automatically updating a profile picture if it&#39;s approved.</p>

			</div>
			<hr>
			<div class="chapter">
				<h2 id="using-signalr-to-asynchronously-update-profile-pictures">Using SignalR to Asynchronously Update Profile Pictures</h2>
<p>In the last several chapters, you learned how to create an asynchronous image analysis process using Azure functions, blob storage, and the Cognitive Services Computer Vision API. Even though we automated the profile picture review and approval process, we inadvertently created another problem: our web app doesn&#39;t support the asynchronous process (meaning, users must continuously refresh their browser to check if their profile picture was approved). </p>
<p>If there were only a way to notify the web browser when a profile picture was approved. There is: <a href="https://www.asp.net/signalr">ASP.NET SignalR</a>.</p>
<ul>
<li><strong>DEFINITION:</strong> ASP.NET SignalR (commonly known as simple SignalR) is a library for ASP.NET developers that makes developing real-time web functionality easy. SignalR allows bi-directional communication between server and client. Servers can now push content to connected clients instantly as it becomes available. SignalR supports Web Sockets, and falls back to other compatible techniques for older browsers.</li>
</ul>
<p>In this chapter, you&#39;ll learn how to use SignalR to notify users on the profile management page when profile pictures are approved.</p>
<h3 id="what-you-re-building">What You&#39;re Building</h3>
<p>Before we jump into modifying our web app, let&#39;s take a quick look at the process SignalR will help us establish:</p>
<p>After a user updates their profile picture, our app will redirect to the profile management page. When the page loads, JavaScript on the page will establish a connection to a SignalR hub. SignalR hubs allow apps to make remote procedure calls (RPCs) from a server to connected clients. After connecting to the SignalR hub, the profile management page waits and listens for a message from the server. If the user browses away from the page, the browser stops listening and disconnects from the SignalR hub.</p>
<p>When the Azure function finishes processing an acceptable profile picture, it POSTs an HTTP request to a Web API endpoint hosted in our web app. The Web API endpoint pushes a message to the clients listening to the SignalR hub. The message includes the profile picture file name that was just accepted.</p>
<p>Back on the client side, when a message is received, the page determines if the profile picture accepted by the Azure function is the picture uploaded by the client. If it is, the image is reloaded by appending a random query string to the image&#39;s source URL.</p>
<h3 id="adding-signalr-to-the-web-app">Adding SignalR to the Web App</h3>
<p>In this exercise, you&#39;ll be adding SignalR to the web app by creating:</p>
<ul>
<li>client-side JavaScript to listen for hub messages</li>
<li>a SignalR hub to send messages </li>
</ul>
<h4 class="exercise-start">
    <b>Exercise</b>: Add SignalR to the web app
</h4>

<p>Install SignalR by adding the following NuGet packages. Note that by installing <em>Microsoft.AspNet.SignalR</em>, the remainder of the packages should install because they&#39;re dependencies.</p>
<ul>
<li>Microsoft.AspNet.SignalR</li>
<li>Microsoft.AspNet.SignalR.Core</li>
<li>Microsoft.AspNet.SignalR.JS</li>
<li>Microsoft.AspNet.SignalR.SystemWeb</li>
</ul>
<p><img src="images/chapter9/install-signalr.png" alt="image"></p>
<h4 id="manage-index-cshtml">Manage\Index.cshtml</h4>
<p>Add a SignalR script reference and hub listener code to the <em>Manage\Index</em> view. When you add this reference, be sure to check the version of SignalR installed. You can find the version number by looking in the <em>Scripts</em> folder of the MVC app. Look for a file named <em>jquery.signalr-X.Y.Z.js</em>, where X.Y.Z is the MAJOR.MINOR.PATCH version number of SignalR. Our version is v2.2.1.</p>
<p><img src="images/chapter9/check-signalr-version.png" alt="image"></p>
<p>Add the JavaScript code snippet to the bottom of the view.</p>
<pre><code class="lang-javascript">@section scripts {
    &lt;!--Reference the SignalR library - make sure it&#39;s version matches the installed version.--&gt;
    &lt;script src=&quot;~/Scripts/jquery.signalR-2.2.1.min.js&quot;&gt;&lt;/script&gt;
    &lt;!--Reference the auto-generated SignalR hub script.--&gt;
    &lt;script src=&quot;~/signalr/hubs&quot;&gt;&lt;/script&gt;
    &lt;!--SignalR script to handle profile picture updated message.--&gt;
    &lt;script&gt;
        $(function () {
            // Reference the auto-generated proxy for the hub
            var profilePic = $.connection.profilePicHub;

            // Function the hub calls to notify the page a profile picture has 
            // been updated
            profilePic.client.profilePicUpdated = function (profilePicUrl) {
                if (profilePicUrl) {
                    var expectedProfilePicUrl = $(&quot;#profilePictureUrl&quot;).val();
                    if (expectedProfilePicUrl === profilePicUrl) {
                        $(&quot;#profilePicture&quot;).attr(&quot;src&quot;, profilePicUrl + &quot;?&quot; + Math.random());
                    }
                }
            };

            // Start the hub connection
            $.connection.hub.start().done(function () {
                // do nothing extra on load of the hub, but if we needed
                // to do something special, we could
            });
        });
    &lt;/script&gt;
}
</code></pre>
<p>In the code snippet above, 3 things happen when the page loads:</p>
<ol>
<li><p>A reference to the profile picture SignalR hub (<code>$.connection.profilePicHub</code>) is stored. You may be wondering why/how the JavaScript code knows what <code>profilePicHub</code> is. For now, just know that SignalR creates that for you automatically when the page loads, and that you&#39;ll learn more about it later in this chapter.</p>
</li>
<li><p>We establish a client-side function (<code>profilePic.client.profilePicUpdated</code>) that is called when the server pushes a method. The URL of the profile picture is passed to this function. The function uses a hidden field on the page (remember adding <code>@Html.HiddenFor(x =&gt; x.ProfilePicUrl, new { id = &quot;profilePictureUrl&quot; })</code> to the MVC view earlier?) . The hidden field is used to check whether the URL passed to the function is the URL of the current user&#39;s profile picture. If it is, the profile picture image&#39;s source property is updated with a random query string: this is a cool trick to force the image to be reloaded. </p>
</li>
<li><p>The connection with the SignalR hub is established, beginning the listening process. When the hub connection starts, we have the opportunity to run additional code, but in our circumstance, there&#39;s no need.</p>
</li>
</ol>
<blockquote>
<p><strong>NOTE:</strong> You may be wondering why we&#39;re checking to ensure the URL passed to a client is the right URL. Imagine several users upload profile pictures simultaneously, each placing their picture in the <em>uploaded</em> blob container. The Azure function indiscriminately processes each image, and POSTs back to our Web API endpoint. The web app then broadcasts the picture URL to all clients connected to the SignalR hub. It&#39;s because of this broadcast that clients receive messages from the server about their image and others images. There <em>are</em> ways to change the way SignalR works, but for the purposes of this workshop, we&#39;ve stuck with the broadcast approach. But, in a more professional setting, you wouldn&#39;t want to broadcast messages to clients that either aren&#39;t expecting them or to which they don&#39;t pertain.</p>
</blockquote>
<h4 id="profilepichub-cs">ProfilePicHub.cs</h4>
<p>Next, we&#39;ll create our SignalR hub by adding a new class to the root of the web app project. Name the class <em>ProfilePicHub</em> and add the code below. </p>
<blockquote>
<ul>
<li><strong>DEFINITION:</strong> SignalR hubs allow apps to make remote procedure calls (RPCs) from a server to connected clients. The hub manages and maintains the list of connected clients transparently, so you don&#39;t have to worry about it.</li>
</ul>
</blockquote>
<pre><code class="lang-csharp">using Microsoft.AspNet.SignalR;

namespace Web
{
    public class ProfilePicHub : Hub
    {
        private readonly ProfilePicBroadcaster _profilePicture;

        public ProfilePicHub(ProfilePicBroadcaster profilePicture)
        {
            _profilePicture = profilePicture;
        }
    }
}
</code></pre>
<p>As you can see, there&#39;s not much going on in the <em>ProfilePicHub</em> class, but that&#39;s because all the heavy lifting is being done in the inherited <em>Hub</em> class.</p>
<blockquote>
<p><strong>NOTE:</strong> The name of the <em>ProfilePicHub</em> class isn&#39;t a coincidence. Earlier in this exercise, you created a reference to the SignalR hub in JavaScript: <code>var profilePic = $.connection.profilePicHub;</code>. When you inherit from the <em>Hub</em> class, SignalR will create a JavaScript object of the same name, placing it inside of the <code>$.connection</code> object.</p>
</blockquote>
<p>You&#39;ll also notice the <em>ProfilePicBroadcaster</em> class that is passed in as a dependency to this class. This class lives up to it&#39;s name and broadcasts messages when a profile picture is updated. We have yet to define the class, so let&#39;s tackle that now.</p>
<h4 id="profilepicbroadcaster-cs">ProfilePicBroadcaster.cs</h4>
<p>Add another class to the root of the web app named <em>ProfilePicBroadcaster</em> and add the following code to it.</p>
<pre><code class="lang-csharp">using Microsoft.AspNet.SignalR;
using Microsoft.AspNet.SignalR.Hubs;
using System;

namespace Web
{
    /// &lt;summary&gt;
    ///  FROM https://docs.microsoft.com/en-us/aspnet/signalr/overview/getting-started/tutorial-server-broadcast-with-signalr
    /// &lt;/summary&gt;
    public class ProfilePicBroadcaster
    {
        // Code block 1: singleton instance of this class to maintain a single
        // list of connected clients across the entire app
        private readonly static Lazy&lt;ProfilePicBroadcaster&gt; _instance = new Lazy&lt;ProfilePicBroadcaster&gt;(() =&gt; new ProfilePicBroadcaster(GlobalHost.ConnectionManager.GetHubContext&lt;ProfilePicHub&gt;().Clients));

        // Code block 2: constructor
        private ProfilePicBroadcaster(IHubConnectionContext&lt;dynamic&gt; clients)
        {
            Clients = clients;
        }

        // Code block 3: public static accessor to create the singleton of this class
        public static ProfilePicBroadcaster Instance
        {
            get
            {
                return _instance.Value;
            }
        }

        // Code block 4: private list of connected clients
        private IHubConnectionContext&lt;dynamic&gt; Clients
        {
            get;
            set;
        }

        // Code block 5: public function to broadcast a message to all connected clients
        public void BroadcastUpdatedProfilePic(string profilePicUrl)
        {
            Clients.All.profilePicUpdated(profilePicUrl);
        }
    }
}
</code></pre>
<p>This looks like a lot of code, but it&#39;s really straight forward if you break it down the right way. The code was adapted from the official <a href="https://docs.microsoft.com/en-us/aspnet/signalr/overview/getting-started/tutorial-server-broadcast-with-signalr">SignalR getting started tutorial</a>. It&#39;s worth checking out if you want to get an idea of everything SignalR can do.</p>
<p>In whole, the purpose of this class is to store a reference to the connected SignalR clients, and provide a mechanism to broadcast a message to all clients.</p>
<p>More specifically, there&#39;s 5 code blocks:</p>
<ul>
<li><p>Blocks 1-4 work together to lazily instantiate a singleton instance of this class. The class is intended to be used like a factory class, where you obtain an instantiated reference of the class through the <code>ProfilePicBroadcaster.Instance</code> property. When this property is referenced the first time, the <code>private readonly static _instance</code> variable is created. The code is a bit pretentious and may look confusing if you don&#39;t have any experience with the <code>Lazy&lt;&gt;</code> class and the singleton pattern. An easy way to think of these 4 code blocks is to know that when you call <code>ProfilePicBroadcaster.Instance</code> one or more times, you&#39;ll get the same instance of the object, meaning .NET only fires the constructor once and only uses the memory space once. </p>
</li>
<li><p>Block 5 is the only public instance method of the class. When called, it broadcasts a message to all connected clients by calling a method on <code>Clients.All</code>. You may notice something interesting about the method name called: <code>profilePicUpdated(profilePicUrl)</code>. This method is actually the method name we created in JavaScript earlier on the <code>client</code> object: <code>profilePic.client.profilePicUpdated = function (profilePicUrl) { ... };</code>. As long as the names of these methods are identical, SignalR passes data between the C# function call you&#39;ve written here and the JavaScript function. Pretty cool.</p>
</li>
</ul>
<blockquote>
<p><strong>NOTE:</strong> We dropped a few development pattern names (singleton and factory) in this exercise, but didn&#39;t take the time to define them. We&#39;re not going to dive into the definition of these here, because others have written about them extensively. We particularly like Martin Fowler&#39;s explanation of these. His articles on <a href="https://martinfowler.com/articles/injection.html">Inversion of Control</a> covers both of these. If you&#39;ve never taken the time to read it, it&#39;s highly recommended.</p>
</blockquote>
<h4 id="startup-cs">Startup.cs</h4>
<p>Ok, we&#39;re almost finished. The last step to configuring SignalR is to add it to the web app&#39;s startup process. Open the <em>Startup.cs</em> class in the root of the web project and add a line to configure SignalR: <code>app.MapSignalR();</code>.</p>
<pre><code class="lang-csharp">using Microsoft.Owin;
using Owin;

[assembly: OwinStartupAttribute(typeof(Web.Startup))]
namespace Web
{
    public partial class Startup
    {
        public void Configuration(IAppBuilder app)
        {
            ConfigureAuth(app);
            app.MapSignalR();
        }
    }
}
</code></pre>
<div class="exercise-end"></div>

<h3 id="adding-a-web-api-endpoint">Adding a Web API Endpoint</h3>
<p>Nice work! You&#39;ve added SignalR to your web project. But, it doesn&#39;t do us much good if we can&#39;t trigger <code>ProfilePicBroadcaster.BroadcastUpdatedProfilePic()</code> from our Azure function. </p>
<p>There&#39;s a multitude of ways to solve this problem, but we&#39;ve chosen something straight-forward: add a Web API endpoint that can trigger the broadcast method. Let&#39;s get started building this out.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add a Web API Endpoint
</h4>

<p>Add Web API to the solution by adding 4 packages. Note that you should only need to install <code>Microsoft.AspNet.WebApi</code> because the other packages are dependencies that will be added automatically.</p>
<p>Install these 4 NuGet packages:</p>
<ul>
<li>Microsoft.AspNet.WebApi</li>
<li>Microsoft.AspNet.WebApi.Core</li>
<li>Microsoft.AspNet.WebApi.WebHost</li>
<li>Microsoft.AspNet.WebApi.Client</li>
</ul>
<h4 id="webapiconfig-cs">WebApiConfig.cs</h4>
<p>Create a file named <em>WebApiConfig.cs</em> in the <em>App_Start</em> folder. Add this code to the file, which configures several defaults for Web API.</p>
<pre><code class="lang-csharp">using System;
using System.Collections.Generic;
using System.Linq;
using System.Web.Http;

namespace Web
{
    public static class WebApiConfig
    {
        public static void Register(HttpConfiguration config)
        {
            config.MapHttpAttributeRoutes();

            config.Routes.MapHttpRoute(
                name: &quot;DefaultApi&quot;,
                routeTemplate: &quot;api/{controller}/{id}&quot;,
                defaults: new { id = RouteParameter.Optional }
            );
        }
    }
}
</code></pre>
<h4 id="global-asax-cs">Global.asax.cs</h4>
<p>Open the <em>Global.asax.cs</em> file and add a reference to <code>System.Web.Http</code> at the top:</p>
<pre><code class="lang-csharp">using System.Web.Http;
</code></pre>
<p>Keep <em>Global.asax.cs</em> open and add register Web API by adding <code>GlobalConfiguration.Configure(WebApiConfig.Register);</code> before <code>RouteConfig.RegisterRoutes(...)</code> is called:</p>
<pre><code class="lang-csharp">using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.Mvc;
using System.Web.Optimization;
using System.Web.Routing;
using System.Web.Http;

namespace Web
{
    public class MvcApplication : System.Web.HttpApplication
    {
        protected void Application_Start()
        {
            //ElCamino - Added to create azure tables
            ApplicationUserManager.StartupAsync();

            AreaRegistration.RegisterAllAreas();
            FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters);
            GlobalConfiguration.Configure(WebApiConfig.Register); // register Web API before registering routes
            RouteConfig.RegisterRoutes(RouteTable.Routes);
            BundleConfig.RegisterBundles(BundleTable.Bundles);
        }
    }
}
</code></pre>
<p>Well, that&#39;s all it takes to add Web API to the project, so let&#39;s start using it by adding an endpoint. </p>
<h4 id="profilepicturecontroller-cs">ProfilePictureController.cs</h4>
<p>Add a new Web API controller named <em>ProfilePicture</em> by adding a class to the <em>Controllers</em> folder named <em>ProfilePictureController.cs</em>. Add this code:</p>
<pre><code class="lang-csharp">using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Web.Http;

namespace Web.Controllers
{
    public class ProfilePictureController : ApiController
    {
        [HttpPost]
        public void Post([FromBody] string profilePicUrl)
        {
            ProfilePicBroadcaster.Instance.BroadcastUpdatedProfilePic(profilePicUrl);
        }
    }
}
</code></pre>
<p>This Web API endpoint will be hosted from <em>~\api\ProfilePicture</em> and accept a URL in the HTTP POST body. When it&#39;s called, it uses the <code>ProfilePicBroadcaster</code> class you created earlier to broadcast the URL to all connected clients. </p>
<blockquote>
<p><strong>NOTE:</strong> In a real-world scenario, I&#39;d <em>never</em> leave a Web API endpoint completely open to the public. I&#39;d secure it with some type of authentication and authorization like OAuth, or at least an API key. But, for our purposes of this lab, we&#39;re going to leave it wide open. Just understand this is a <em>bad</em> practice. </p>
</blockquote>
<div class="exercise-end"></div>

<p>That&#39;s it! We&#39;re finished with the web project. But, there&#39;s something you&#39;ll need to do before moving on.</p>
<blockquote>
<p><strong>WARNING:</strong> It&#39;s critical that you re-publish the project to the Azure web app you created earlier. In the next section, you&#39;ll be updating your Azure function to POST the update profile picture URL to a <em>public</em> Web API endpoint. If your Web API endpoint isn&#39;t publicly exposed, the Azure function won&#39;t be able to communicate with it.</p>
</blockquote>
<h3 id="calling-a-web-api-endpoint-from-an-azure-function">Calling a Web API Endpoint from an Azure Function</h3>
<p>The last step is to call the Web API endpoint from the Azure function after a profile picture is accepted as an appropriate picture. </p>
<h4 class="exercise-start">
    <b>Exercise</b>: Call a Web API Endpoint from an Azure Function
</h4>

<p>Navigate back to the <a href="https://portal.azure.com">Azure portal</a> and find your Azure function app on the dashboard you created earlier.</p>
<p><img src="images/chapter9/open-function-app.png" class="img-small" /></p>
<p>Open the function app and locate the <code>BlobImageAnalysis</code> function.</p>
<p><img src="images/chapter9/open-function.png" class="img-small" /></p>
<p>Replace the function code with the code below.</p>
<pre><code class="lang-csharp">using Microsoft.WindowsAzure.Storage.Blob;
using Microsoft.WindowsAzure.Storage;
using System.Net.Http.Headers;
using System.Configuration;
using System.Text;
using System.Web.Http;
using System.Net;

public async static Task Run(Stream myBlob, string name, string ext, TraceWriter log)
{       
    log.Info($&quot;Analyzing uploaded image {name} for appropriate content...&quot;);

    var array = await ToByteArrayAsync(myBlob);
    var result = await AnalyzeImageAsync(array, log);

    log.Info(&quot;Is Adult: &quot; + result.adult.isAdultContent.ToString());
    log.Info(&quot;Adult Score: &quot; + result.adult.adultScore.ToString());
    log.Info(&quot;Is Racy: &quot; + result.adult.isRacyContent.ToString()); 
    log.Info(&quot;Racy Score: &quot; + result.adult.racyScore.ToString());

    // Reset stream location
    myBlob.Seek(0, SeekOrigin.Begin);
    if (result.adult.isAdultContent || result.adult.isRacyContent)
    {
        // profile picture is NOT acceptable - copy blob to the &quot;rejected&quot; container
        StoreBlobWithMetadata(myBlob, &quot;rejected&quot;, name, ext, result, log);
    }
    else
    {
        // profile picture is acceptable - copy blob to the &quot;profile-pics&quot; container
        StoreBlobWithMetadata(myBlob, &quot;profile-pics&quot;, name, ext, result, log);

        log.Info($&quot;Calling signalR for image {name}.{ext}&quot;);

        // alert SignalR hub
        var webApiEndpointBaseUrl = ConfigurationManager.AppSettings[&quot;WebAPIEndpointBaseUrl&quot;].ToString();
        WebRequest request = WebRequest.Create($&quot;{webApiEndpointBaseUrl}/api/ProfilePicture&quot;);
        request.Method = &quot;POST&quot;;
        request.ContentType = &quot;application/x-www-form-urlencoded&quot;;

        ASCIIEncoding encoding = new ASCIIEncoding();
        var storageAccountName = ConfigurationManager.AppSettings[&quot;StorageAccountName&quot;].ToString();
        var stringData = $&quot;=https://{storageAccountName}.blob.core.windows.net/profile-pics/{name}.{ext}&quot;;
        var data = encoding.GetBytes(stringData);
        request.ContentLength = data.Length;

        Stream newStream = request.GetRequestStream();
        newStream.Write(data, 0, data.Length);
        newStream.Close();
        request.GetResponse();

        log.Info($&quot;SignalR call finished&quot;);
    }
}

private async static Task&lt;ImageAnalysisInfo&gt; AnalyzeImageAsync(byte[] bytes, TraceWriter log)
{
    HttpClient client = new HttpClient();

    var key = ConfigurationManager.AppSettings[&quot;SubscriptionKey&quot;].ToString();
    client.DefaultRequestHeaders.Add(&quot;Ocp-Apim-Subscription-Key&quot;, key);

    HttpContent payload = new ByteArrayContent(bytes);
    payload.Headers.ContentType = new MediaTypeWithQualityHeaderValue(&quot;application/octet-stream&quot;);

    var results = await client.PostAsync(&quot;https://westus.api.cognitive.microsoft.com/vision/v1.0/analyze?visualFeatures=Adult&quot;, payload);
    var result = await results.Content.ReadAsAsync&lt;ImageAnalysisInfo&gt;();
    return result;
}

// Writes a blob to a specified container and stores metadata with it
private static void StoreBlobWithMetadata(Stream image, string containerName, string blobName, string ext, ImageAnalysisInfo info, TraceWriter log)
{
    log.Info($&quot;Writing blob and metadata to {containerName} container...&quot;);

    var connection = ConfigurationManager.AppSettings[&quot;AzureWebJobsStorage&quot;].ToString();
    var account = CloudStorageAccount.Parse(connection);
    var client = account.CreateCloudBlobClient();
    var container = client.GetContainerReference(containerName);

    try
    {
        var blob = container.GetBlockBlobReference($&quot;{blobName}.{ext}&quot;);

        if (blob != null) 
        {
            // Upload the blob
            blob.UploadFromStream(image);

            // Set the content type of the image
            blob.Properties.ContentType = &quot;image/&quot; + ext;
            blob.SetProperties();

            // Get the blob attributes
            blob.FetchAttributes();

            // Write the blob metadata
            blob.Metadata[&quot;isAdultContent&quot;] = info.adult.isAdultContent.ToString(); 
            blob.Metadata[&quot;adultScore&quot;] = info.adult.adultScore.ToString(&quot;P0&quot;).Replace(&quot; &quot;,&quot;&quot;); 
            blob.Metadata[&quot;isRacyContent&quot;] = info.adult.isRacyContent.ToString(); 
            blob.Metadata[&quot;racyScore&quot;] = info.adult.racyScore.ToString(&quot;P0&quot;).Replace(&quot; &quot;,&quot;&quot;); 

            // Save the blob metadata
            blob.SetMetadata();
        }
    }
    catch (Exception ex)
    {
        log.Info(ex.Message);
    }
}

// Converts a stream to a byte array 
private async static Task&lt;byte[]&gt; ToByteArrayAsync(Stream stream)
{
    Int32 length = stream.Length &gt; Int32.MaxValue ? Int32.MaxValue : Convert.ToInt32(stream.Length);
    byte[] buffer = new Byte[length];
    await stream.ReadAsync(buffer, 0, length);
    return buffer;
}

public class ImageAnalysisInfo
{
    public Adult adult { get; set; }
    public string requestId { get; set; }
}

public class Adult
{
    public bool isAdultContent { get; set; }
    public bool isRacyContent { get; set; }
    public float adultScore { get; set; }
    public float racyScore { get; set; }
}
</code></pre>
<p>The code added uses two configuration app settings to POST the URL of the profile picture when it&#39;s acceptable.</p>
<p>Return to the <em>Application Settings</em> area of the function app.</p>
<p><img src="images/chapter9/goto-app-settings.gif" class="img-large" /></p>
<p>Add app settings for <code>WebAPIEndpointBaseUrl</code> and <code>StorageAccountName</code>:</p>
<ul>
<li><strong>WebAPIEndpointBaseUrl:</strong> set to the URL of the web app you created for this workshop, i.e., <em><a href="http://globalazurelouisville.azurewebsites.net">http://globalazurelouisville.azurewebsites.net</a></em>. Do not include an ending slash.</li>
<li><strong>StorageAccountName:</strong> set to the name of the storage account you created for this workshop</li>
</ul>
<p><img src="images/chapter9/add-app-settings.png" class="img-medium" /></p>
<p>You&#39;re finished!</p>
<div class="exercise-end"></div>

<p>Wow! That was a lot of changes, but we think it was worth it. Browse out to the Azure-hosted URL of your web app (ours is <em><a href="http://louglobalazure2017.azurewebsites.net/">http://louglobalazure2017.azurewebsites.net/</a></em>). You&#39;ll note this URL is different from the others in the guide, but it has the same functionality.</p>
<p>When you upload a new profile picture, you&#39;ll navigate back to the profile management page. After a few seconds, you should see the image update after the the Azure function analyzes it with the Cognitive Services API and calls the Web API endpoint we created. The Web API endpoint broadcasts the profile picture URL to all connected SignalR hub clients. When this is received by the listener in JavaScript, the source property of the image is updated to include a random query string, causing the image to re-fresh.</p>
<p>It&#39;s beautiful.</p>
<p><img src="images/chapter9/signalr-update.gif" class="img-large" /></p>
<h4 id="summary">Summary</h4>
<p>In this chapter you learned:</p>
<ul>
<li>SignalR hubs can be used to broadcast messages from a server to connected clients</li>
<li>How to call a Web API endpoint from an Azure function</li>
</ul>

			</div>
		</div>
	</div>
</div>

<script src="scripts/built.js"></script>

</body>
</html>